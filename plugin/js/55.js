"use strict";(self.webpackChunkgantt_on_kintone=self.webpackChunkgantt_on_kintone||[]).push([[55],{8055:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ insertMarkers$1),\n/* harmony export */   b: () => (/* binding */ clear$1),\n/* harmony export */   c: () => (/* binding */ createLabel$1),\n/* harmony export */   d: () => (/* binding */ clear),\n/* harmony export */   e: () => (/* binding */ insertNode),\n/* harmony export */   f: () => (/* binding */ insertEdgeLabel),\n/* harmony export */   g: () => (/* binding */ getSubGraphTitleMargins),\n/* harmony export */   h: () => (/* binding */ insertEdge),\n/* harmony export */   i: () => (/* binding */ intersectRect$1),\n/* harmony export */   j: () => (/* binding */ positionEdgeLabel),\n/* harmony export */   k: () => (/* binding */ getLineFunctionsWithOffset),\n/* harmony export */   l: () => (/* binding */ labelHelper),\n/* harmony export */   m: () => (/* binding */ addEdgeMarkers),\n/* harmony export */   p: () => (/* binding */ positionNode),\n/* harmony export */   s: () => (/* binding */ setNodeElem),\n/* harmony export */   u: () => (/* binding */ updateNodeBounds)\n/* harmony export */ });\n/* harmony import */ var _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5950);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8918);\n/* harmony import */ var _createText_ca0c5216_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4274);\n\n\n\nconst insertMarkers = (elem, markerArray, type, id) => {\n  markerArray.forEach((markerName) => {\n    markers[markerName](elem, type, id);\n  });\n};\nconst extension = (elem, type, id) => {\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.trace("Making markers for ", id);\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-extensionStart").attr("class", "marker extension " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-extensionEnd").attr("class", "marker extension " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");\n};\nconst composition = (elem, type, id) => {\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-compositionStart").attr("class", "marker composition " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-compositionEnd").attr("class", "marker composition " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n};\nconst aggregation = (elem, type, id) => {\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-aggregationStart").attr("class", "marker aggregation " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-aggregationEnd").attr("class", "marker aggregation " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n};\nconst dependency = (elem, type, id) => {\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-dependencyStart").attr("class", "marker dependency " + type).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-dependencyEnd").attr("class", "marker dependency " + type).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");\n};\nconst lollipop = (elem, type, id) => {\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-lollipopStart").attr("class", "marker lollipop " + type).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-lollipopEnd").attr("class", "marker lollipop " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);\n};\nconst point = (elem, type, id) => {\n  elem.append("marker").attr("id", id + "_" + type + "-pointEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n  elem.append("marker").attr("id", id + "_" + type + "-pointStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n};\nconst circle$1 = (elem, type, id) => {\n  elem.append("marker").attr("id", id + "_" + type + "-circleEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n  elem.append("marker").attr("id", id + "_" + type + "-circleStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n};\nconst cross = (elem, type, id) => {\n  elem.append("marker").attr("id", id + "_" + type + "-crossEnd").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");\n  elem.append("marker").attr("id", id + "_" + type + "-crossStart").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");\n};\nconst barb = (elem, type, id) => {\n  elem.append("defs").append("marker").attr("id", id + "_" + type + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");\n};\nconst markers = {\n  extension,\n  composition,\n  aggregation,\n  dependency,\n  lollipop,\n  point,\n  circle: circle$1,\n  cross,\n  barb\n};\nconst insertMarkers$1 = insertMarkers;\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr("style", styleFn);\n  }\n}\nfunction addHtmlLabel(node) {\n  const fo = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"));\n  const div = fo.append("xhtml:div");\n  const label = node.label;\n  const labelClass = node.isNode ? "nodeLabel" : "edgeLabel";\n  div.html(\n    \'<span class="\' + labelClass + \'" \' + (node.labelStyle ? \'style="\' + node.labelStyle + \'"\' : "") + ">" + label + "</span>"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style("display", "inline-block");\n  div.style("white-space", "nowrap");\n  div.attr("xmlns", "http://www.w3.org/1999/xhtml");\n  return fo.node();\n}\nconst createLabel = (_vertexText, style, isTitle, isNode) => {\n  let vertexText = _vertexText || "";\n  if (typeof vertexText === "object") {\n    vertexText = vertexText[0];\n  }\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    vertexText = vertexText.replace(/\\\\n|\\n/g, "<br />");\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("vertexText" + vertexText);\n    const node = {\n      isNode,\n      label: (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.M)(vertexText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        // cspell: disable-line\n        (s) => `<i class=\'${s.replace(":", " ")}\'></i>`\n      ),\n      labelStyle: style.replace("fill:", "color:")\n    };\n    let vertexNode = addHtmlLabel(node);\n    return vertexNode;\n  } else {\n    const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");\n    svgLabel.setAttribute("style", style.replace("color:", "fill:"));\n    let rows = [];\n    if (typeof vertexText === "string") {\n      rows = vertexText.split(/\\\\n|\\n|<br\\s*\\/?>/gi);\n    } else if (Array.isArray(vertexText)) {\n      rows = vertexText;\n    } else {\n      rows = [];\n    }\n    for (const row of rows) {\n      const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");\n      tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");\n      tspan.setAttribute("dy", "1em");\n      tspan.setAttribute("x", "0");\n      if (isTitle) {\n        tspan.setAttribute("class", "title-row");\n      } else {\n        tspan.setAttribute("class", "row");\n      }\n      tspan.textContent = row.trim();\n      svgLabel.appendChild(tspan);\n    }\n    return svgLabel;\n  }\n};\nconst createLabel$1 = createLabel;\nconst labelHelper = async (parent, node, _classes, isNode) => {\n  let classes;\n  const useHtmlLabels = node.useHtmlLabels || (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels);\n  if (!_classes) {\n    classes = "node default";\n  } else {\n    classes = _classes;\n  }\n  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);\n  const label = shapeSvg.insert("g").attr("class", "label").attr("style", node.labelStyle);\n  let labelText;\n  if (node.labelText === void 0) {\n    labelText = "";\n  } else {\n    labelText = typeof node.labelText === "string" ? node.labelText : node.labelText[0];\n  }\n  const textNode = label.node();\n  let text;\n  if (node.labelType === "markdown") {\n    text = (0,_createText_ca0c5216_js__WEBPACK_IMPORTED_MODULE_2__.a)(label, (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.d)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.M)(labelText), (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)()), {\n      useHtmlLabels,\n      width: node.width || (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.wrappingWidth,\n      classes: "markdown-node-label"\n    });\n  } else {\n    text = textNode.appendChild(\n      createLabel$1(\n        (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.d)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.M)(labelText), (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)()),\n        node.labelStyle,\n        false,\n        isNode\n      )\n    );\n  }\n  let bbox = text.getBBox();\n  const halfPadding = node.padding / 2;\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(text);\n    const images = div.getElementsByTagName("img");\n    if (images) {\n      const noImgText = labelText.replace(/<img[^>]*>/g, "").trim() === "";\n      await Promise.all(\n        [...images].map(\n          (img) => new Promise((res) => {\n            function setupImage() {\n              img.style.display = "flex";\n              img.style.flexDirection = "column";\n              if (noImgText) {\n                const bodyFontSize = (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().fontSize ? (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().fontSize : window.getComputedStyle(document.body).fontSize;\n                const enlargingFactor = 5;\n                const width = parseInt(bodyFontSize, 10) * enlargingFactor + "px";\n                img.style.minWidth = width;\n                img.style.maxWidth = width;\n              } else {\n                img.style.width = "100%";\n              }\n              res(img);\n            }\n            setTimeout(() => {\n              if (img.complete) {\n                setupImage();\n              }\n            });\n            img.addEventListener("error", setupImage);\n            img.addEventListener("load", setupImage);\n          })\n        )\n      );\n    }\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  if (useHtmlLabels) {\n    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");\n  } else {\n    label.attr("transform", "translate(0, " + -bbox.height / 2 + ")");\n  }\n  if (node.centerLabel) {\n    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");\n  }\n  label.insert("rect", ":first-child");\n  return { shapeSvg, bbox, halfPadding, label };\n};\nconst updateNodeBounds = (node, element) => {\n  const bbox = element.node().getBBox();\n  node.width = bbox.width;\n  node.height = bbox.height;\n};\nfunction insertPolygonShape(parent, w, h, points) {\n  return parent.insert("polygon", ":first-child").attr(\n    "points",\n    points.map(function(d) {\n      return d.x + "," + d.y;\n    }).join(" ")\n  ).attr("class", "label-container").attr("transform", "translate(" + -w / 2 + "," + h / 2 + ")");\n}\nfunction intersectNode(node, point2) {\n  return node.intersect(point2);\n}\nfunction intersectEllipse(node, rx, ry, point2) {\n  var cx = node.x;\n  var cy = node.y;\n  var px = cx - point2.x;\n  var py = cy - point2.y;\n  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);\n  var dx = Math.abs(rx * ry * px / det);\n  if (point2.x < cx) {\n    dx = -dx;\n  }\n  var dy = Math.abs(rx * ry * py / det);\n  if (point2.y < cy) {\n    dy = -dy;\n  }\n  return { x: cx + dx, y: cy + dy };\n}\nfunction intersectCircle(node, rx, point2) {\n  return intersectEllipse(node, rx, rx, point2);\n}\nfunction intersectLine(p1, p2, q1, q2) {\n  var a1, a2, b1, b2, c1, c2;\n  var r1, r2, r3, r4;\n  var denom, offset, num;\n  var x, y;\n  a1 = p2.y - p1.y;\n  b1 = p1.x - p2.x;\n  c1 = p2.x * p1.y - p1.x * p2.y;\n  r3 = a1 * q1.x + b1 * q1.y + c1;\n  r4 = a1 * q2.x + b1 * q2.y + c1;\n  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {\n    return;\n  }\n  a2 = q2.y - q1.y;\n  b2 = q1.x - q2.x;\n  c2 = q2.x * q1.y - q1.x * q2.y;\n  r1 = a2 * p1.x + b2 * p1.y + c2;\n  r2 = a2 * p2.x + b2 * p2.y + c2;\n  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {\n    return;\n  }\n  denom = a1 * b2 - a2 * b1;\n  if (denom === 0) {\n    return;\n  }\n  offset = Math.abs(denom / 2);\n  num = b1 * c2 - b2 * c1;\n  x = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  num = a2 * c1 - a1 * c2;\n  y = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  return { x, y };\n}\nfunction sameSign(r1, r2) {\n  return r1 * r2 > 0;\n}\nfunction intersectPolygon(node, polyPoints, point2) {\n  var x1 = node.x;\n  var y1 = node.y;\n  var intersections = [];\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  if (typeof polyPoints.forEach === "function") {\n    polyPoints.forEach(function(entry) {\n      minX = Math.min(minX, entry.x);\n      minY = Math.min(minY, entry.y);\n    });\n  } else {\n    minX = Math.min(minX, polyPoints.x);\n    minY = Math.min(minY, polyPoints.y);\n  }\n  var left = x1 - node.width / 2 - minX;\n  var top = y1 - node.height / 2 - minY;\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect2 = intersectLine(\n      node,\n      point2,\n      { x: left + p1.x, y: top + p1.y },\n      { x: left + p2.x, y: top + p2.y }\n    );\n    if (intersect2) {\n      intersections.push(intersect2);\n    }\n  }\n  if (!intersections.length) {\n    return node;\n  }\n  if (intersections.length > 1) {\n    intersections.sort(function(p, q) {\n      var pdx = p.x - point2.x;\n      var pdy = p.y - point2.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n      var qdx = q.x - point2.x;\n      var qdy = q.y - point2.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n      return distp < distq ? -1 : distp === distq ? 0 : 1;\n    });\n  }\n  return intersections[0];\n}\nconst intersectRect = (node, point2) => {\n  var x = node.x;\n  var y = node.y;\n  var dx = point2.x - x;\n  var dy = point2.y - y;\n  var w = node.width / 2;\n  var h = node.height / 2;\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = dy === 0 ? 0 : h * dx / dy;\n    sy = h;\n  } else {\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = dx === 0 ? 0 : w * dy / dx;\n  }\n  return { x: x + sx, y: y + sy };\n};\nconst intersectRect$1 = intersectRect;\nconst intersect = {\n  node: intersectNode,\n  circle: intersectCircle,\n  ellipse: intersectEllipse,\n  polygon: intersectPolygon,\n  rect: intersectRect$1\n};\nconst note = async (parent, node) => {\n  const useHtmlLabels = node.useHtmlLabels || (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels;\n  if (!useHtmlLabels) {\n    node.centerLabel = true;\n  }\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    "node " + node.classes,\n    true\n  );\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Classes = ", node.classes);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  rect2.attr("rx", node.rx).attr("ry", node.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst note$1 = note;\nconst expandAndDeduplicateDirections = (directions) => {\n  const uniqueDirections = /* @__PURE__ */ new Set();\n  for (const direction of directions) {\n    switch (direction) {\n      case "x":\n        uniqueDirections.add("right");\n        uniqueDirections.add("left");\n        break;\n      case "y":\n        uniqueDirections.add("up");\n        uniqueDirections.add("down");\n        break;\n      default:\n        uniqueDirections.add(direction);\n        break;\n    }\n  }\n  return uniqueDirections;\n};\nconst getArrowPoints = (duplicatedDirections, bbox, node) => {\n  const directions = expandAndDeduplicateDirections(duplicatedDirections);\n  const f = 2;\n  const height = bbox.height + 2 * node.padding;\n  const midpoint = height / f;\n  const width = bbox.width + 2 * midpoint + node.padding;\n  const padding = node.padding / 2;\n  if (directions.has("right") && directions.has("left") && directions.has("up") && directions.has("down")) {\n    return [\n      // Bottom\n      { x: 0, y: 0 },\n      { x: midpoint, y: 0 },\n      { x: width / 2, y: 2 * padding },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: 0 },\n      // Right\n      { x: width, y: -height / 3 },\n      { x: width + 2 * padding, y: -height / 2 },\n      { x: width, y: -2 * height / 3 },\n      { x: width, y: -height },\n      // Top\n      { x: width - midpoint, y: -height },\n      { x: width / 2, y: -height - 2 * padding },\n      { x: midpoint, y: -height },\n      // Left\n      { x: 0, y: -height },\n      { x: 0, y: -2 * height / 3 },\n      { x: -2 * padding, y: -height / 2 },\n      { x: 0, y: -height / 3 }\n    ];\n  }\n  if (directions.has("right") && directions.has("left") && directions.has("up")) {\n    return [\n      { x: midpoint, y: 0 },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: -height / 2 },\n      { x: width - midpoint, y: -height },\n      { x: midpoint, y: -height },\n      { x: 0, y: -height / 2 }\n    ];\n  }\n  if (directions.has("right") && directions.has("left") && directions.has("down")) {\n    return [\n      { x: 0, y: 0 },\n      { x: midpoint, y: -height },\n      { x: width - midpoint, y: -height },\n      { x: width, y: 0 }\n    ];\n  }\n  if (directions.has("right") && directions.has("up") && directions.has("down")) {\n    return [\n      { x: 0, y: 0 },\n      { x: width, y: -midpoint },\n      { x: width, y: -height + midpoint },\n      { x: 0, y: -height }\n    ];\n  }\n  if (directions.has("left") && directions.has("up") && directions.has("down")) {\n    return [\n      { x: width, y: 0 },\n      { x: 0, y: -midpoint },\n      { x: 0, y: -height + midpoint },\n      { x: width, y: -height }\n    ];\n  }\n  if (directions.has("right") && directions.has("left")) {\n    return [\n      { x: midpoint, y: 0 },\n      { x: midpoint, y: -padding },\n      { x: width - midpoint, y: -padding },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: -height / 2 },\n      { x: width - midpoint, y: -height },\n      { x: width - midpoint, y: -height + padding },\n      { x: midpoint, y: -height + padding },\n      { x: midpoint, y: -height },\n      { x: 0, y: -height / 2 }\n    ];\n  }\n  if (directions.has("up") && directions.has("down")) {\n    return [\n      // Bottom center\n      { x: width / 2, y: 0 },\n      // Left pont of bottom arrow\n      { x: 0, y: -padding },\n      { x: midpoint, y: -padding },\n      // Left top over vertical section\n      { x: midpoint, y: -height + padding },\n      { x: 0, y: -height + padding },\n      // Top of arrow\n      { x: width / 2, y: -height },\n      { x: width, y: -height + padding },\n      // Top of right vertical bar\n      { x: width - midpoint, y: -height + padding },\n      { x: width - midpoint, y: -padding },\n      { x: width, y: -padding }\n    ];\n  }\n  if (directions.has("right") && directions.has("up")) {\n    return [\n      { x: 0, y: 0 },\n      { x: width, y: -midpoint },\n      { x: 0, y: -height }\n    ];\n  }\n  if (directions.has("right") && directions.has("down")) {\n    return [\n      { x: 0, y: 0 },\n      { x: width, y: 0 },\n      { x: 0, y: -height }\n    ];\n  }\n  if (directions.has("left") && directions.has("up")) {\n    return [\n      { x: width, y: 0 },\n      { x: 0, y: -midpoint },\n      { x: width, y: -height }\n    ];\n  }\n  if (directions.has("left") && directions.has("down")) {\n    return [\n      { x: width, y: 0 },\n      { x: 0, y: 0 },\n      { x: width, y: -height }\n    ];\n  }\n  if (directions.has("right")) {\n    return [\n      { x: midpoint, y: -padding },\n      { x: midpoint, y: -padding },\n      { x: width - midpoint, y: -padding },\n      { x: width - midpoint, y: 0 },\n      { x: width, y: -height / 2 },\n      { x: width - midpoint, y: -height },\n      { x: width - midpoint, y: -height + padding },\n      // top left corner of arrow\n      { x: midpoint, y: -height + padding },\n      { x: midpoint, y: -height + padding }\n    ];\n  }\n  if (directions.has("left")) {\n    return [\n      { x: midpoint, y: 0 },\n      { x: midpoint, y: -padding },\n      // Two points, the right corners\n      { x: width - midpoint, y: -padding },\n      { x: width - midpoint, y: -height + padding },\n      { x: midpoint, y: -height + padding },\n      { x: midpoint, y: -height },\n      { x: 0, y: -height / 2 }\n    ];\n  }\n  if (directions.has("up")) {\n    return [\n      // Bottom center\n      { x: midpoint, y: -padding },\n      // Left top over vertical section\n      { x: midpoint, y: -height + padding },\n      { x: 0, y: -height + padding },\n      // Top of arrow\n      { x: width / 2, y: -height },\n      { x: width, y: -height + padding },\n      // Top of right vertical bar\n      { x: width - midpoint, y: -height + padding },\n      { x: width - midpoint, y: -padding }\n    ];\n  }\n  if (directions.has("down")) {\n    return [\n      // Bottom center\n      { x: width / 2, y: 0 },\n      // Left pont of bottom arrow\n      { x: 0, y: -padding },\n      { x: midpoint, y: -padding },\n      // Left top over vertical section\n      { x: midpoint, y: -height + padding },\n      { x: width - midpoint, y: -height + padding },\n      { x: width - midpoint, y: -padding },\n      { x: width, y: -padding }\n    ];\n  }\n  return [{ x: 0, y: 0 }];\n};\nconst formatClass = (str) => {\n  if (str) {\n    return " " + str;\n  }\n  return "";\n};\nconst getClassesFromNode = (node, otherClasses) => {\n  return `${otherClasses ? otherClasses : "node default"}${formatClass(node.classes)} ${formatClass(\n    node.class\n  )}`;\n};\nconst question = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const s = w + h;\n  const points = [\n    { x: s / 2, y: 0 },\n    { x: s, y: -s / 2 },\n    { x: s / 2, y: -s },\n    { x: 0, y: -s / 2 }\n  ];\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Question main (Circle)");\n  const questionElem = insertPolygonShape(shapeSvg, s, s, points);\n  questionElem.attr("style", node.style);\n  updateNodeBounds(node, questionElem);\n  node.intersect = function(point2) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("Intersect called");\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst choice = (parent, node) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  const s = 28;\n  const points = [\n    { x: 0, y: s / 2 },\n    { x: s / 2, y: 0 },\n    { x: 0, y: -s / 2 },\n    { x: -s / 2, y: 0 }\n  ];\n  const choice2 = shapeSvg.insert("polygon", ":first-child").attr(\n    "points",\n    points.map(function(d) {\n      return d.x + "," + d.y;\n    }).join(" ")\n  );\n  choice2.attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28);\n  node.width = 28;\n  node.height = 28;\n  node.intersect = function(point2) {\n    return intersect.circle(node, 14, point2);\n  };\n  return shapeSvg;\n};\nconst hexagon = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const f = 4;\n  const h = bbox.height + node.padding;\n  const m = h / f;\n  const w = bbox.width + 2 * m + node.padding;\n  const points = [\n    { x: m, y: 0 },\n    { x: w - m, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w - m, y: -h },\n    { x: m, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  const hex = insertPolygonShape(shapeSvg, w, h, points);\n  hex.attr("style", node.style);\n  updateNodeBounds(node, hex);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst block_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const f = 2;\n  const h = bbox.height + 2 * node.padding;\n  const m = h / f;\n  const w = bbox.width + 2 * m + node.padding;\n  const points = getArrowPoints(node.directions, bbox, node);\n  const blockArrow = insertPolygonShape(shapeSvg, w, h, points);\n  blockArrow.attr("style", node.style);\n  updateNodeBounds(node, blockArrow);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_left_inv_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -h / 2, y: 0 },\n    { x: w, y: 0 },\n    { x: w, y: -h },\n    { x: -h / 2, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  node.width = w + h;\n  node.height = h;\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_right = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node), true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -2 * h / 6, y: 0 },\n    { x: w - h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: -h },\n    { x: h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_left = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 2 * h / 6, y: 0 },\n    { x: w + h / 6, y: 0 },\n    { x: w - 2 * h / 6, y: -h },\n    { x: -h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst trapezoid = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -2 * h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: 0 },\n    { x: w - h / 6, y: -h },\n    { x: h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst inv_trapezoid = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: h / 6, y: 0 },\n    { x: w - h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: -h },\n    { x: -2 * h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_right_inv_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 0, y: 0 },\n    { x: w + h / 2, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w + h / 2, y: -h },\n    { x: 0, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst cylinder = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const rx = w / 2;\n  const ry = rx / (2.5 + w / 50);\n  const h = bbox.height + ry + node.padding;\n  const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w + " 0 a " + rx + "," + ry + " 0,0,0 " + -w + " 0 l 0," + h + " a " + rx + "," + ry + " 0,0,0 " + w + " 0 l 0," + -h;\n  const el = shapeSvg.attr("label-offset-y", ry).insert("path", ":first-child").attr("style", node.style).attr("d", shape).attr("transform", "translate(" + -w / 2 + "," + -(h / 2 + ry) + ")");\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    const pos = intersect.rect(node, point2);\n    const x = pos.x - node.x;\n    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {\n      let y = ry * ry * (1 - x * x / (rx * rx));\n      if (y != 0) {\n        y = Math.sqrt(y);\n      }\n      y = ry - y;\n      if (point2.y - node.y > 0) {\n        y = -y;\n      }\n      pos.y += y;\n    }\n    return pos;\n  };\n  return shapeSvg;\n};\nconst rect = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    "node " + node.classes + " " + node.class,\n    true\n  );\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const totalWidth = node.positioned ? node.width : bbox.width + node.padding;\n  const totalHeight = node.positioned ? node.height : bbox.height + node.padding;\n  const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;\n  const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;\n  rect2.attr("class", "basic label-container").attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("x", x).attr("y", y).attr("width", totalWidth).attr("height", totalHeight);\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete("borders");\n    }\n    propKeys.forEach((propKey) => {\n      _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst composite = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    "node " + node.classes,\n    true\n  );\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const totalWidth = node.positioned ? node.width : bbox.width + node.padding;\n  const totalHeight = node.positioned ? node.height : bbox.height + node.padding;\n  const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;\n  const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;\n  rect2.attr("class", "basic cluster composite label-container").attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("x", x).attr("y", y).attr("width", totalWidth).attr("height", totalHeight);\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete("borders");\n    }\n    propKeys.forEach((propKey) => {\n      _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst labelRect = async (parent, node) => {\n  const { shapeSvg } = await labelHelper(parent, node, "label", true);\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.trace("Classes = ", node.class);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const totalWidth = 0;\n  const totalHeight = 0;\n  rect2.attr("width", totalWidth).attr("height", totalHeight);\n  shapeSvg.attr("class", "label edgeLabel");\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete("borders");\n    }\n    propKeys.forEach((propKey) => {\n      _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nfunction applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {\n  const strokeDashArray = [];\n  const addBorder = (length) => {\n    strokeDashArray.push(length, 0);\n  };\n  const skipBorder = (length) => {\n    strokeDashArray.push(0, length);\n  };\n  if (borders.includes("t")) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add top border");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes("r")) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add right border");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  if (borders.includes("b")) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add bottom border");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes("l")) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add left border");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  rect2.attr("stroke-dasharray", strokeDashArray.join(" "));\n}\nconst rectWithTitle = (parent, node) => {\n  let classes;\n  if (!node.classes) {\n    classes = "node default";\n  } else {\n    classes = "node " + node.classes;\n  }\n  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const innerLine = shapeSvg.insert("line");\n  const label = shapeSvg.insert("g").attr("class", "label");\n  const text2 = node.labelText.flat ? node.labelText.flat() : node.labelText;\n  let title = "";\n  if (typeof text2 === "object") {\n    title = text2[0];\n  } else {\n    title = text2;\n  }\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Label text abc79", title, text2, typeof text2 === "object");\n  const text = label.node().appendChild(createLabel$1(title, node.labelStyle, true, true));\n  let bbox = { width: 0, height: 0 };\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Text 2", text2);\n  const textRows = text2.slice(1, text2.length);\n  let titleBox = text.getBBox();\n  const descr = label.node().appendChild(\n    createLabel$1(textRows.join ? textRows.join("<br/>") : textRows, node.labelStyle, true, true)\n  );\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = descr.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(descr);\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  const halfPadding = node.padding / 2;\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(descr).attr(\n    "transform",\n    "translate( " + // (titleBox.width - bbox.width) / 2 +\n    (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ", " + (titleBox.height + halfPadding + 5) + ")"\n  );\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(text).attr(\n    "transform",\n    "translate( " + // (titleBox.width - bbox.width) / 2 +\n    (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ", 0)"\n  );\n  bbox = label.node().getBBox();\n  label.attr(\n    "transform",\n    "translate(" + -bbox.width / 2 + ", " + (-bbox.height / 2 - halfPadding + 3) + ")"\n  );\n  rect2.attr("class", "outer title-state").attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  innerLine.attr("class", "divider").attr("x1", -bbox.width / 2 - halfPadding).attr("x2", bbox.width / 2 + halfPadding).attr("y1", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr("y2", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst stadium = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const h = bbox.height + node.padding;\n  const w = bbox.width + h / 4 + node.padding;\n  const rect2 = shapeSvg.insert("rect", ":first-child").attr("style", node.style).attr("rx", h / 2).attr("ry", h / 2).attr("x", -w / 2).attr("y", -h / 2).attr("width", w).attr("height", h);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst circle = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const circle2 = shapeSvg.insert("circle", ":first-child");\n  circle2.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Circle main");\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Circle intersect", node, bbox.width / 2 + halfPadding, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding, point2);\n  };\n  return shapeSvg;\n};\nconst doublecircle = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const gap = 5;\n  const circleGroup = shapeSvg.insert("g", ":first-child");\n  const outerCircle = circleGroup.insert("circle");\n  const innerCircle = circleGroup.insert("circle");\n  circleGroup.attr("class", node.class);\n  outerCircle.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding + gap).attr("width", bbox.width + node.padding + gap * 2).attr("height", bbox.height + node.padding + gap * 2);\n  innerCircle.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("DoubleCircle main");\n  updateNodeBounds(node, outerCircle);\n  node.intersect = function(point2) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.info("DoubleCircle intersect", node, bbox.width / 2 + halfPadding + gap, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding + gap, point2);\n  };\n  return shapeSvg;\n};\nconst subroutine = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(\n    parent,\n    node,\n    getClassesFromNode(node, void 0),\n    true\n  );\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 0, y: 0 },\n    { x: w, y: 0 },\n    { x: w, y: -h },\n    { x: 0, y: -h },\n    { x: 0, y: 0 },\n    { x: -8, y: 0 },\n    { x: w + 8, y: 0 },\n    { x: w + 8, y: -h },\n    { x: -8, y: -h },\n    { x: -8, y: 0 }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst start = (parent, node) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  const circle2 = shapeSvg.insert("circle", ":first-child");\n  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst forkJoin = (parent, node, dir) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  let width = 70;\n  let height = 10;\n  if (dir === "LR") {\n    width = 10;\n    height = 70;\n  }\n  const shape = shapeSvg.append("rect").attr("x", -1 * width / 2).attr("y", -1 * height / 2).attr("width", width).attr("height", height).attr("class", "fork-join");\n  updateNodeBounds(node, shape);\n  node.height = node.height + node.padding / 2;\n  node.width = node.width + node.padding / 2;\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst end = (parent, node) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  const innerCircle = shapeSvg.insert("circle", ":first-child");\n  const circle2 = shapeSvg.insert("circle", ":first-child");\n  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);\n  innerCircle.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10);\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst class_box = (parent, node) => {\n  const halfPadding = node.padding / 2;\n  const rowPadding = 4;\n  const lineHeight = 8;\n  let classes;\n  if (!node.classes) {\n    classes = "node default";\n  } else {\n    classes = "node " + node.classes;\n  }\n  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const topLine = shapeSvg.insert("line");\n  const bottomLine = shapeSvg.insert("line");\n  let maxWidth = 0;\n  let maxHeight = rowPadding;\n  const labelContainer = shapeSvg.insert("g").attr("class", "label");\n  let verticalPos = 0;\n  const hasInterface = node.classData.annotations && node.classData.annotations[0];\n  const interfaceLabelText = node.classData.annotations[0] ? "«" + node.classData.annotations[0] + "»" : "";\n  const interfaceLabel = labelContainer.node().appendChild(createLabel$1(interfaceLabelText, node.labelStyle, true, true));\n  let interfaceBBox = interfaceLabel.getBBox();\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = interfaceLabel.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(interfaceLabel);\n    interfaceBBox = div.getBoundingClientRect();\n    dv.attr("width", interfaceBBox.width);\n    dv.attr("height", interfaceBBox.height);\n  }\n  if (node.classData.annotations[0]) {\n    maxHeight += interfaceBBox.height + rowPadding;\n    maxWidth += interfaceBBox.width;\n  }\n  let classTitleString = node.classData.label;\n  if (node.classData.type !== void 0 && node.classData.type !== "") {\n    if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels) {\n      classTitleString += "&lt;" + node.classData.type + "&gt;";\n    } else {\n      classTitleString += "<" + node.classData.type + ">";\n    }\n  }\n  const classTitleLabel = labelContainer.node().appendChild(createLabel$1(classTitleString, node.labelStyle, true, true));\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(classTitleLabel).attr("class", "classTitle");\n  let classTitleBBox = classTitleLabel.getBBox();\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = classTitleLabel.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(classTitleLabel);\n    classTitleBBox = div.getBoundingClientRect();\n    dv.attr("width", classTitleBBox.width);\n    dv.attr("height", classTitleBBox.height);\n  }\n  maxHeight += classTitleBBox.height + rowPadding;\n  if (classTitleBBox.width > maxWidth) {\n    maxWidth = classTitleBBox.width;\n  }\n  const classAttributes = [];\n  node.classData.members.forEach((member) => {\n    const parsedInfo = member.getDisplayDetails();\n    let parsedText = parsedInfo.displayText;\n    if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels) {\n      parsedText = parsedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");\n    }\n    const lbl = labelContainer.node().appendChild(\n      createLabel$1(\n        parsedText,\n        parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle,\n        true,\n        true\n      )\n    );\n    let bbox = lbl.getBBox();\n    if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr("width", bbox.width);\n      dv.attr("height", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classAttributes.push(lbl);\n  });\n  maxHeight += lineHeight;\n  const classMethods = [];\n  node.classData.methods.forEach((member) => {\n    const parsedInfo = member.getDisplayDetails();\n    let displayText = parsedInfo.displayText;\n    if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels) {\n      displayText = displayText.replace(/</g, "&lt;").replace(/>/g, "&gt;");\n    }\n    const lbl = labelContainer.node().appendChild(\n      createLabel$1(\n        displayText,\n        parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle,\n        true,\n        true\n      )\n    );\n    let bbox = lbl.getBBox();\n    if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr("width", bbox.width);\n      dv.attr("height", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classMethods.push(lbl);\n  });\n  maxHeight += lineHeight;\n  if (hasInterface) {\n    let diffX2 = (maxWidth - interfaceBBox.width) / 2;\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(interfaceLabel).attr(\n      "transform",\n      "translate( " + (-1 * maxWidth / 2 + diffX2) + ", " + -1 * maxHeight / 2 + ")"\n    );\n    verticalPos = interfaceBBox.height + rowPadding;\n  }\n  let diffX = (maxWidth - classTitleBBox.width) / 2;\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(classTitleLabel).attr(\n    "transform",\n    "translate( " + (-1 * maxWidth / 2 + diffX) + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"\n  );\n  verticalPos += classTitleBBox.height + rowPadding;\n  topLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classAttributes.forEach((lbl) => {\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(lbl).attr(\n      "transform",\n      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + ")"\n    );\n    const memberBBox = lbl == null ? void 0 : lbl.getBBox();\n    verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;\n  });\n  verticalPos += lineHeight;\n  bottomLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classMethods.forEach((lbl) => {\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(lbl).attr(\n      "transform",\n      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"\n    );\n    const memberBBox = lbl == null ? void 0 : lbl.getBBox();\n    verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;\n  });\n  rect2.attr("style", node.style).attr("class", "outer title-state").attr("x", -maxWidth / 2 - halfPadding).attr("y", -(maxHeight / 2) - halfPadding).attr("width", maxWidth + node.padding).attr("height", maxHeight + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst shapes = {\n  rhombus: question,\n  composite,\n  question,\n  rect,\n  labelRect,\n  rectWithTitle,\n  choice,\n  circle,\n  doublecircle,\n  stadium,\n  hexagon,\n  block_arrow,\n  rect_left_inv_arrow,\n  lean_right,\n  lean_left,\n  trapezoid,\n  inv_trapezoid,\n  rect_right_inv_arrow,\n  cylinder,\n  start,\n  end,\n  note: note$1,\n  subroutine,\n  fork: forkJoin,\n  join: forkJoin,\n  class_box\n};\nlet nodeElems = {};\nconst insertNode = async (elem, node, dir) => {\n  let newEl;\n  let el;\n  if (node.link) {\n    let target;\n    if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().securityLevel === "sandbox") {\n      target = "_top";\n    } else if (node.linkTarget) {\n      target = node.linkTarget || "_blank";\n    }\n    newEl = elem.insert("svg:a").attr("xlink:href", node.link).attr("target", target);\n    el = await shapes[node.shape](newEl, node, dir);\n  } else {\n    el = await shapes[node.shape](elem, node, dir);\n    newEl = el;\n  }\n  if (node.tooltip) {\n    el.attr("title", node.tooltip);\n  }\n  if (node.class) {\n    el.attr("class", "node default " + node.class);\n  }\n  newEl.attr("data-node", "true");\n  newEl.attr("data-id", node.id);\n  nodeElems[node.id] = newEl;\n  if (node.haveCallback) {\n    nodeElems[node.id].attr("class", nodeElems[node.id].attr("class") + " clickable");\n  }\n  return newEl;\n};\nconst setNodeElem = (elem, node) => {\n  nodeElems[node.id] = elem;\n};\nconst clear$1 = () => {\n  nodeElems = {};\n};\nconst positionNode = (node) => {\n  const el = nodeElems[node.id];\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.trace(\n    "Transforming node",\n    node.diff,\n    node,\n    "translate(" + (node.x - node.width / 2 - 5) + ", " + node.width / 2 + ")"\n  );\n  const padding = 8;\n  const diff = node.diff || 0;\n  if (node.clusterNode) {\n    el.attr(\n      "transform",\n      "translate(" + (node.x + diff - node.width / 2) + ", " + (node.y - node.height / 2 - padding) + ")"\n    );\n  } else {\n    el.attr("transform", "translate(" + node.x + ", " + node.y + ")");\n  }\n  return diff;\n};\nconst getSubGraphTitleMargins = ({\n  flowchart\n}) => {\n  var _a, _b;\n  const subGraphTitleTopMargin = ((_a = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _a.top) ?? 0;\n  const subGraphTitleBottomMargin = ((_b = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _b.bottom) ?? 0;\n  const subGraphTitleTotalMargin = subGraphTitleTopMargin + subGraphTitleBottomMargin;\n  return {\n    subGraphTitleTopMargin,\n    subGraphTitleBottomMargin,\n    subGraphTitleTotalMargin\n  };\n};\nconst markerOffsets = {\n  aggregation: 18,\n  extension: 18,\n  composition: 18,\n  dependency: 6,\n  lollipop: 13.5,\n  arrow_point: 5.3\n};\nfunction calculateDeltaAndAngle(point1, point2) {\n  if (point1 === void 0 || point2 === void 0) {\n    return { angle: 0, deltaX: 0, deltaY: 0 };\n  }\n  point1 = pointTransformer(point1);\n  point2 = pointTransformer(point2);\n  const [x1, y1] = [point1.x, point1.y];\n  const [x2, y2] = [point2.x, point2.y];\n  const deltaX = x2 - x1;\n  const deltaY = y2 - y1;\n  return { angle: Math.atan(deltaY / deltaX), deltaX, deltaY };\n}\nconst pointTransformer = (data) => {\n  if (Array.isArray(data)) {\n    return { x: data[0], y: data[1] };\n  }\n  return data;\n};\nconst getLineFunctionsWithOffset = (edge) => {\n  return {\n    x: function(d, i, data) {\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const { angle, deltaX } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const { angle, deltaX } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).x + offset;\n    },\n    y: function(d, i, data) {\n      let offset = 0;\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      }\n      return pointTransformer(d).y + offset;\n    }\n  };\n};\nconst addEdgeMarkers = (svgPath, edge, url, id, diagramType) => {\n  if (edge.arrowTypeStart) {\n    addEdgeMarker(svgPath, "start", edge.arrowTypeStart, url, id, diagramType);\n  }\n  if (edge.arrowTypeEnd) {\n    addEdgeMarker(svgPath, "end", edge.arrowTypeEnd, url, id, diagramType);\n  }\n};\nconst arrowTypesMap = {\n  arrow_cross: "cross",\n  arrow_point: "point",\n  arrow_barb: "barb",\n  arrow_circle: "circle",\n  aggregation: "aggregation",\n  extension: "extension",\n  composition: "composition",\n  dependency: "dependency",\n  lollipop: "lollipop"\n};\nconst addEdgeMarker = (svgPath, position, arrowType, url, id, diagramType) => {\n  const endMarkerType = arrowTypesMap[arrowType];\n  if (!endMarkerType) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`Unknown arrow type: ${arrowType}`);\n    return;\n  }\n  const suffix = position === "start" ? "Start" : "End";\n  svgPath.attr(`marker-${position}`, `url(${url}#${id}_${diagramType}-${endMarkerType}${suffix})`);\n};\nlet edgeLabels = {};\nlet terminalLabels = {};\nconst clear = () => {\n  edgeLabels = {};\n  terminalLabels = {};\n};\nconst insertEdgeLabel = (elem, edge) => {\n  const useHtmlLabels = (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.m)((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels);\n  const labelElement = edge.labelType === "markdown" ? (0,_createText_ca0c5216_js__WEBPACK_IMPORTED_MODULE_2__.a)(elem, edge.label, {\n    style: edge.labelStyle,\n    useHtmlLabels,\n    addSvgBackground: true\n  }) : createLabel$1(edge.label, edge.labelStyle);\n  const edgeLabel = elem.insert("g").attr("class", "edgeLabel");\n  const label = edgeLabel.insert("g").attr("class", "label");\n  label.node().appendChild(labelElement);\n  let bbox = labelElement.getBBox();\n  if (useHtmlLabels) {\n    const div = labelElement.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Ltv)(labelElement);\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");\n  edgeLabels[edge.id] = edgeLabel;\n  edge.width = bbox.width;\n  edge.height = bbox.height;\n  let fo;\n  if (edge.startLabelLeft) {\n    const startLabelElement = createLabel$1(edge.startLabelLeft, edge.labelStyle);\n    const startEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = startEdgeLabelLeft.insert("g").attr("class", "inner");\n    fo = inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startLeft = startEdgeLabelLeft;\n    setTerminalWidth(fo, edge.startLabelLeft);\n  }\n  if (edge.startLabelRight) {\n    const startLabelElement = createLabel$1(edge.startLabelRight, edge.labelStyle);\n    const startEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = startEdgeLabelRight.insert("g").attr("class", "inner");\n    fo = startEdgeLabelRight.node().appendChild(startLabelElement);\n    inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startRight = startEdgeLabelRight;\n    setTerminalWidth(fo, edge.startLabelRight);\n  }\n  if (edge.endLabelLeft) {\n    const endLabelElement = createLabel$1(edge.endLabelLeft, edge.labelStyle);\n    const endEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = endEdgeLabelLeft.insert("g").attr("class", "inner");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    endEdgeLabelLeft.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endLeft = endEdgeLabelLeft;\n    setTerminalWidth(fo, edge.endLabelLeft);\n  }\n  if (edge.endLabelRight) {\n    const endLabelElement = createLabel$1(edge.endLabelRight, edge.labelStyle);\n    const endEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = endEdgeLabelRight.insert("g").attr("class", "inner");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    endEdgeLabelRight.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endRight = endEdgeLabelRight;\n    setTerminalWidth(fo, edge.endLabelRight);\n  }\n  return labelElement;\n};\nfunction setTerminalWidth(fo, value) {\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels && fo) {\n    fo.style.width = value.length * 9 + "px";\n    fo.style.height = "12px";\n  }\n}\nconst positionEdgeLabel = (edge, paths) => {\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("Moving label abc88 ", edge.id, edge.label, edgeLabels[edge.id], paths);\n  let path = paths.updatedPath ? paths.updatedPath : paths.originalPath;\n  const siteConfig = (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)();\n  const { subGraphTitleTotalMargin } = getSubGraphTitleMargins(siteConfig);\n  if (edge.label) {\n    const el = edgeLabels[edge.id];\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.u.calcLabelPosition(path);\n      _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(\n        "Moving label " + edge.label + " from (",\n        x,\n        ",",\n        y,\n        ") to (",\n        pos.x,\n        ",",\n        pos.y,\n        ") abc88"\n      );\n      if (paths.updatedPath) {\n        x = pos.x;\n        y = pos.y;\n      }\n    }\n    el.attr("transform", `translate(${x}, ${y + subGraphTitleTotalMargin / 2})`);\n  }\n  if (edge.startLabelLeft) {\n    const el = terminalLabels[edge.id].startLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_left", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", `translate(${x}, ${y})`);\n  }\n  if (edge.startLabelRight) {\n    const el = terminalLabels[edge.id].startRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(\n        edge.arrowTypeStart ? 10 : 0,\n        "start_right",\n        path\n      );\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", `translate(${x}, ${y})`);\n  }\n  if (edge.endLabelLeft) {\n    const el = terminalLabels[edge.id].endLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_left", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", `translate(${x}, ${y})`);\n  }\n  if (edge.endLabelRight) {\n    const el = terminalLabels[edge.id].endRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_right", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", `translate(${x}, ${y})`);\n  }\n};\nconst outsideNode = (node, point2) => {\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(point2.x - x);\n  const dy = Math.abs(point2.y - y);\n  const w = node.width / 2;\n  const h = node.height / 2;\n  if (dx >= w || dy >= h) {\n    return true;\n  }\n  return false;\n};\nconst intersection = (node, outsidePoint, insidePoint) => {\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(`intersection calc abc89:\n  outsidePoint: ${JSON.stringify(outsidePoint)}\n  insidePoint : ${JSON.stringify(insidePoint)}\n  node        : x:${node.x} y:${node.y} w:${node.width} h:${node.height}`);\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(x - insidePoint.x);\n  const w = node.width / 2;\n  let r = insidePoint.x < outsidePoint.x ? w - dx : w + dx;\n  const h = node.height / 2;\n  const Q = Math.abs(outsidePoint.y - insidePoint.y);\n  const R = Math.abs(outsidePoint.x - insidePoint.x);\n  if (Math.abs(y - outsidePoint.y) * w > Math.abs(x - outsidePoint.x) * h) {\n    let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;\n    r = R * q / Q;\n    const res = {\n      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,\n      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q\n    };\n    if (r === 0) {\n      res.x = outsidePoint.x;\n      res.y = outsidePoint.y;\n    }\n    if (R === 0) {\n      res.x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      res.y = outsidePoint.y;\n    }\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);\n    return res;\n  } else {\n    if (insidePoint.x < outsidePoint.x) {\n      r = outsidePoint.x - w - x;\n    } else {\n      r = x - w - outsidePoint.x;\n    }\n    let q = Q * r / R;\n    let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;\n    let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, { _x, _y });\n    if (r === 0) {\n      _x = outsidePoint.x;\n      _y = outsidePoint.y;\n    }\n    if (R === 0) {\n      _x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      _y = outsidePoint.y;\n    }\n    return { x: _x, y: _y };\n  }\n};\nconst cutPathAtIntersect = (_points, boundaryNode) => {\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("abc88 cutPathAtIntersect", _points, boundaryNode);\n  let points = [];\n  let lastPointOutside = _points[0];\n  let isInside = false;\n  _points.forEach((point2) => {\n    if (!outsideNode(boundaryNode, point2) && !isInside) {\n      const inter = intersection(boundaryNode, lastPointOutside, point2);\n      let pointPresent = false;\n      points.forEach((p) => {\n        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;\n      });\n      if (!points.some((e) => e.x === inter.x && e.y === inter.y)) {\n        points.push(inter);\n      }\n      isInside = true;\n    } else {\n      lastPointOutside = point2;\n      if (!isInside) {\n        points.push(point2);\n      }\n    }\n  });\n  return points;\n};\nconst insertEdge = function(elem, e, edge, clusterDb, diagramType, graph, id) {\n  let points = edge.points;\n  _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("abc88 InsertEdge: edge=", edge, "e=", e);\n  let pointsHasChanged = false;\n  const tail = graph.node(e.v);\n  var head = graph.node(e.w);\n  if ((head == null ? void 0 : head.intersect) && (tail == null ? void 0 : tail.intersect)) {\n    points = points.slice(1, edge.points.length - 1);\n    points.unshift(tail.intersect(points[0]));\n    points.push(head.intersect(points[points.length - 1]));\n  }\n  if (edge.toCluster) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("to cluster abc88", clusterDb[edge.toCluster]);\n    points = cutPathAtIntersect(edge.points, clusterDb[edge.toCluster].node);\n    pointsHasChanged = true;\n  }\n  if (edge.fromCluster) {\n    _mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("from cluster abc88", clusterDb[edge.fromCluster]);\n    points = cutPathAtIntersect(points.reverse(), clusterDb[edge.fromCluster].node).reverse();\n    pointsHasChanged = true;\n  }\n  const lineData = points.filter((p) => !Number.isNaN(p.y));\n  let curve = d3__WEBPACK_IMPORTED_MODULE_0__/* .curveBasis */ .qrM;\n  if (edge.curve && (diagramType === "graph" || diagramType === "flowchart")) {\n    curve = edge.curve;\n  }\n  const { x, y } = getLineFunctionsWithOffset(edge);\n  const lineFunction = (0,d3__WEBPACK_IMPORTED_MODULE_0__/* .line */ .n8j)().x(x).y(y).curve(curve);\n  let strokeClasses;\n  switch (edge.thickness) {\n    case "normal":\n      strokeClasses = "edge-thickness-normal";\n      break;\n    case "thick":\n      strokeClasses = "edge-thickness-thick";\n      break;\n    case "invisible":\n      strokeClasses = "edge-thickness-thick";\n      break;\n    default:\n      strokeClasses = "";\n  }\n  switch (edge.pattern) {\n    case "solid":\n      strokeClasses += " edge-pattern-solid";\n      break;\n    case "dotted":\n      strokeClasses += " edge-pattern-dotted";\n      break;\n    case "dashed":\n      strokeClasses += " edge-pattern-dashed";\n      break;\n  }\n  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", edge.id).attr("class", " " + strokeClasses + (edge.classes ? " " + edge.classes : "")).attr("style", edge.style);\n  let url = "";\n  if ((0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.arrowMarkerAbsolute || (0,_mermaid_6dc72991_js__WEBPACK_IMPORTED_MODULE_1__.c)().state.arrowMarkerAbsolute) {\n    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, "\\\\(");\n    url = url.replace(/\\)/g, "\\\\)");\n  }\n  addEdgeMarkers(svgPath, edge, url, id, diagramType);\n  let paths = {};\n  if (pointsHasChanged) {\n    paths.updatedPath = points;\n  }\n  paths.originalPath = edge.points;\n  return paths;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA1NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0k7QUFDdEY7QUFDYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsbURBQUc7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQVEsQ0FBQyx1REFBUztBQUN4QjtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBO0FBQ0EsYUFBYSx1REFBYztBQUMzQjtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdURBQVEsQ0FBQyx1REFBUztBQUNoRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBEQUFVLFFBQVEsdURBQVksQ0FBQyx1REFBYyxhQUFhLHVEQUFTO0FBQzlFO0FBQ0EsMkJBQTJCLHVEQUFTO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsUUFBUSx1REFBWSxDQUFDLHVEQUFjLGFBQWEsdURBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQVEsQ0FBQyx1REFBUztBQUN4QjtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQVMsY0FBYyx1REFBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtCQUErQjtBQUN2QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1REFBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtREFBRztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVk7QUFDcEIsUUFBUSxtQkFBbUI7QUFDM0IsUUFBUSw4QkFBOEI7QUFDdEMsUUFBUSwyQkFBMkI7QUFDbkMsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLHdDQUF3QztBQUNoRCxRQUFRLDhCQUE4QjtBQUN0QyxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsd0NBQXdDO0FBQ2hELFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0IsUUFBUSwyQkFBMkI7QUFDbkMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSx5QkFBeUI7QUFDakMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCLFFBQVEseUJBQXlCO0FBQ2pDLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWTtBQUNwQixRQUFRLHdCQUF3QjtBQUNoQyxRQUFRLGlDQUFpQztBQUN6QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QixRQUFRLG9CQUFvQjtBQUM1QixRQUFRLDZCQUE2QjtBQUNyQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQixRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLGtDQUFrQztBQUMxQyxRQUFRLDJCQUEyQjtBQUNuQyxRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLDJDQUEyQztBQUNuRCxRQUFRLG1DQUFtQztBQUMzQyxRQUFRLHlCQUF5QjtBQUNqQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0IsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQSxRQUFRLG1DQUFtQztBQUMzQyxRQUFRLDRCQUE0QjtBQUNwQztBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEsZ0NBQWdDO0FBQ3hDO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQsUUFBUSxrQ0FBa0M7QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCLFFBQVEsd0JBQXdCO0FBQ2hDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWTtBQUNwQixRQUFRLGdCQUFnQjtBQUN4QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QixRQUFRLG9CQUFvQjtBQUM1QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QixRQUFRLFlBQVk7QUFDcEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSxrQ0FBa0M7QUFDMUMsUUFBUSwyQkFBMkI7QUFDbkMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSwyQ0FBMkM7QUFDbkQ7QUFDQSxRQUFRLG1DQUFtQztBQUMzQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQixRQUFRLDBCQUEwQjtBQUNsQztBQUNBLFFBQVEsa0NBQWtDO0FBQzFDLFFBQVEsMkNBQTJDO0FBQ25ELFFBQVEsbUNBQW1DO0FBQzNDLFFBQVEseUJBQXlCO0FBQ2pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQSxRQUFRLG1DQUFtQztBQUMzQyxRQUFRLDRCQUE0QjtBQUNwQztBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEsZ0NBQWdDO0FBQ3hDO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0EsUUFBUSxtQ0FBbUM7QUFDM0MsUUFBUSwyQ0FBMkM7QUFDbkQsUUFBUSxrQ0FBa0M7QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQTZDLEVBQUUsMkJBQTJCLEVBQUU7QUFDeEY7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCO0FBQ3RCLE1BQU0saUJBQWlCO0FBQ3ZCLE1BQU0saUJBQWlCO0FBQ3ZCLE1BQU07QUFDTjtBQUNBLEVBQUUsbURBQUc7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQkFBZ0I7QUFDdEIsTUFBTSxnQkFBZ0I7QUFDdEIsTUFBTSxpQkFBaUI7QUFDdkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWTtBQUNsQixNQUFNLGdCQUFnQjtBQUN0QixNQUFNLGlCQUFpQjtBQUN2QixNQUFNLGlCQUFpQjtBQUN2QixNQUFNLGFBQWE7QUFDbkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QixNQUFNLFlBQVk7QUFDbEIsTUFBTSxhQUFhO0FBQ25CLE1BQU0sa0JBQWtCO0FBQ3hCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQkFBcUI7QUFDM0IsTUFBTSxvQkFBb0I7QUFDMUIsTUFBTSx5QkFBeUI7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCLE1BQU0sb0JBQW9CO0FBQzFCLE1BQU0seUJBQXlCO0FBQy9CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQixNQUFNLHdCQUF3QjtBQUM5QixNQUFNLHFCQUFxQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQkFBZ0I7QUFDdEIsTUFBTSxvQkFBb0I7QUFDMUIsTUFBTSx5QkFBeUI7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWTtBQUNsQixNQUFNLG9CQUFvQjtBQUMxQixNQUFNLGlCQUFpQjtBQUN2QixNQUFNLHFCQUFxQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbURBQUcsK0JBQStCLFFBQVE7QUFDaEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFHLCtCQUErQixRQUFRO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCLEVBQUUsbURBQUc7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFHLCtCQUErQixRQUFRO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1EQUFHO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtREFBRztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFLG1EQUFHO0FBQ0w7QUFDQSxlQUFlO0FBQ2YsTUFBTSx1REFBUSxDQUFDLHVEQUFTO0FBQ3hCO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbURBQUc7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBUSxDQUFDLHVEQUFTO0FBQ3hCO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxREFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxREFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtREFBRztBQUNMO0FBQ0E7QUFDQSxJQUFJLG1EQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbURBQUc7QUFDTDtBQUNBO0FBQ0EsSUFBSSxtREFBRztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCLE1BQU0sWUFBWTtBQUNsQixNQUFNLGFBQWE7QUFDbkIsTUFBTSxhQUFhO0FBQ25CLE1BQU0sWUFBWTtBQUNsQixNQUFNLGFBQWE7QUFDbkIsTUFBTSxnQkFBZ0I7QUFDdEIsTUFBTSxpQkFBaUI7QUFDdkIsTUFBTSxjQUFjO0FBQ3BCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBUSxDQUFDLHVEQUFTO0FBQ3hCO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVM7QUFDakIsK0JBQStCLCtCQUErQjtBQUM5RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHFEQUFNO0FBQ1I7QUFDQSxNQUFNLHVEQUFRLENBQUMsdURBQVM7QUFDeEI7QUFDQSxlQUFlLHFEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVM7QUFDakIsaURBQWlELHNCQUFzQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVEsQ0FBQyx1REFBUztBQUMxQjtBQUNBLGlCQUFpQixxREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVM7QUFDakIsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVEsQ0FBQyx1REFBUztBQUMxQjtBQUNBLGlCQUFpQixxREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscURBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVM7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1EQUFHO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBLFFBQVE7QUFDUixnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1EQUFHLDZCQUE2QixVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTLFVBQVUsSUFBSSxHQUFHLEdBQUcsR0FBRyxZQUFZLEdBQUcsY0FBYyxFQUFFLE9BQU87QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBUSxDQUFDLHVEQUFTO0FBQzFDLHVEQUF1RCwwREFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtREFBRztBQUNMO0FBQ0EscUJBQXFCLHVEQUFTO0FBQzlCLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkIsTUFBTSxtREFBRztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLElBQUksaUNBQWlDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxJQUFJLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUUsSUFBSSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxJQUFJLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLElBQUksRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1EQUFHO0FBQ0wsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixvQkFBb0IsUUFBUSxJQUFJLFFBQVEsSUFBSSxZQUFZLElBQUksWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUcsa0NBQWtDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDbkU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtREFBRyw4QkFBOEIsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtREFBRztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtREFBRztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscURBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLHVCQUF1QixtREFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFTLG9DQUFvQyx1REFBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nYW50dC1vbi1raW50b25lLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9lZGdlcy0wNjZhNTU2MS5qcz8wZWY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGwgYXMgbG9nLCBtIGFzIGV2YWx1YXRlLCBjIGFzIGdldENvbmZpZywgTSBhcyBkZWNvZGVFbnRpdGllcywgZCBhcyBzYW5pdGl6ZVRleHQsIHUgYXMgdXRpbHMgfSBmcm9tIFwiLi9tZXJtYWlkLTZkYzcyOTkxLmpzXCI7XG5pbXBvcnQgeyBzZWxlY3QsIGxpbmUsIGN1cnZlQmFzaXMgfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7IGEgYXMgY3JlYXRlVGV4dCB9IGZyb20gXCIuL2NyZWF0ZVRleHQtY2EwYzUyMTYuanNcIjtcbmNvbnN0IGluc2VydE1hcmtlcnMgPSAoZWxlbSwgbWFya2VyQXJyYXksIHR5cGUsIGlkKSA9PiB7XG4gIG1hcmtlckFycmF5LmZvckVhY2goKG1hcmtlck5hbWUpID0+IHtcbiAgICBtYXJrZXJzW21hcmtlck5hbWVdKGVsZW0sIHR5cGUsIGlkKTtcbiAgfSk7XG59O1xuY29uc3QgZXh0ZW5zaW9uID0gKGVsZW0sIHR5cGUsIGlkKSA9PiB7XG4gIGxvZy50cmFjZShcIk1ha2luZyBtYXJrZXJzIGZvciBcIiwgaWQpO1xuICBlbGVtLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwibWFya2VyXCIpLmF0dHIoXCJpZFwiLCBpZCArIFwiX1wiICsgdHlwZSArIFwiLWV4dGVuc2lvblN0YXJ0XCIpLmF0dHIoXCJjbGFzc1wiLCBcIm1hcmtlciBleHRlbnNpb24gXCIgKyB0eXBlKS5hdHRyKFwicmVmWFwiLCAxOCkuYXR0cihcInJlZllcIiwgNykuYXR0cihcIm1hcmtlcldpZHRoXCIsIDE5MCkuYXR0cihcIm1hcmtlckhlaWdodFwiLCAyNDApLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDEsNyBMMTgsMTMgViAxIFpcIik7XG4gIGVsZW0uYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJtYXJrZXJcIikuYXR0cihcImlkXCIsIGlkICsgXCJfXCIgKyB0eXBlICsgXCItZXh0ZW5zaW9uRW5kXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm1hcmtlciBleHRlbnNpb24gXCIgKyB0eXBlKS5hdHRyKFwicmVmWFwiLCAxKS5hdHRyKFwicmVmWVwiLCA3KS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMjApLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMjgpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDEsMSBWIDEzIEwxOCw3IFpcIik7XG59O1xuY29uc3QgY29tcG9zaXRpb24gPSAoZWxlbSwgdHlwZSwgaWQpID0+IHtcbiAgZWxlbS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1jb21wb3NpdGlvblN0YXJ0XCIpLmF0dHIoXCJjbGFzc1wiLCBcIm1hcmtlciBjb21wb3NpdGlvbiBcIiArIHR5cGUpLmF0dHIoXCJyZWZYXCIsIDE4KS5hdHRyKFwicmVmWVwiLCA3KS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMTkwKS5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDI0MCkuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIikuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZFwiLCBcIk0gMTgsNyBMOSwxMyBMMSw3IEw5LDEgWlwiKTtcbiAgZWxlbS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1jb21wb3NpdGlvbkVuZFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgY29tcG9zaXRpb24gXCIgKyB0eXBlKS5hdHRyKFwicmVmWFwiLCAxKS5hdHRyKFwicmVmWVwiLCA3KS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMjApLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMjgpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDE4LDcgTDksMTMgTDEsNyBMOSwxIFpcIik7XG59O1xuY29uc3QgYWdncmVnYXRpb24gPSAoZWxlbSwgdHlwZSwgaWQpID0+IHtcbiAgZWxlbS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1hZ2dyZWdhdGlvblN0YXJ0XCIpLmF0dHIoXCJjbGFzc1wiLCBcIm1hcmtlciBhZ2dyZWdhdGlvbiBcIiArIHR5cGUpLmF0dHIoXCJyZWZYXCIsIDE4KS5hdHRyKFwicmVmWVwiLCA3KS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMTkwKS5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDI0MCkuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIikuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZFwiLCBcIk0gMTgsNyBMOSwxMyBMMSw3IEw5LDEgWlwiKTtcbiAgZWxlbS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1hZ2dyZWdhdGlvbkVuZFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgYWdncmVnYXRpb24gXCIgKyB0eXBlKS5hdHRyKFwicmVmWFwiLCAxKS5hdHRyKFwicmVmWVwiLCA3KS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMjApLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMjgpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDE4LDcgTDksMTMgTDEsNyBMOSwxIFpcIik7XG59O1xuY29uc3QgZGVwZW5kZW5jeSA9IChlbGVtLCB0eXBlLCBpZCkgPT4ge1xuICBlbGVtLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwibWFya2VyXCIpLmF0dHIoXCJpZFwiLCBpZCArIFwiX1wiICsgdHlwZSArIFwiLWRlcGVuZGVuY3lTdGFydFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgZGVwZW5kZW5jeSBcIiArIHR5cGUpLmF0dHIoXCJyZWZYXCIsIDYpLmF0dHIoXCJyZWZZXCIsIDcpLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAxOTApLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMjQwKS5hdHRyKFwib3JpZW50XCIsIFwiYXV0b1wiKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJkXCIsIFwiTSA1LDcgTDksMTMgTDEsNyBMOSwxIFpcIik7XG4gIGVsZW0uYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJtYXJrZXJcIikuYXR0cihcImlkXCIsIGlkICsgXCJfXCIgKyB0eXBlICsgXCItZGVwZW5kZW5jeUVuZFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgZGVwZW5kZW5jeSBcIiArIHR5cGUpLmF0dHIoXCJyZWZYXCIsIDEzKS5hdHRyKFwicmVmWVwiLCA3KS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMjApLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMjgpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDE4LDcgTDksMTMgTDE0LDcgTDksMSBaXCIpO1xufTtcbmNvbnN0IGxvbGxpcG9wID0gKGVsZW0sIHR5cGUsIGlkKSA9PiB7XG4gIGVsZW0uYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJtYXJrZXJcIikuYXR0cihcImlkXCIsIGlkICsgXCJfXCIgKyB0eXBlICsgXCItbG9sbGlwb3BTdGFydFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgbG9sbGlwb3AgXCIgKyB0eXBlKS5hdHRyKFwicmVmWFwiLCAxMykuYXR0cihcInJlZllcIiwgNykuYXR0cihcIm1hcmtlcldpZHRoXCIsIDE5MCkuYXR0cihcIm1hcmtlckhlaWdodFwiLCAyNDApLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcImNpcmNsZVwiKS5hdHRyKFwic3Ryb2tlXCIsIFwiYmxhY2tcIikuYXR0cihcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKS5hdHRyKFwiY3hcIiwgNykuYXR0cihcImN5XCIsIDcpLmF0dHIoXCJyXCIsIDYpO1xuICBlbGVtLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwibWFya2VyXCIpLmF0dHIoXCJpZFwiLCBpZCArIFwiX1wiICsgdHlwZSArIFwiLWxvbGxpcG9wRW5kXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm1hcmtlciBsb2xsaXBvcCBcIiArIHR5cGUpLmF0dHIoXCJyZWZYXCIsIDEpLmF0dHIoXCJyZWZZXCIsIDcpLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAxOTApLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMjQwKS5hdHRyKFwib3JpZW50XCIsIFwiYXV0b1wiKS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpLmF0dHIoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIikuYXR0cihcImN4XCIsIDcpLmF0dHIoXCJjeVwiLCA3KS5hdHRyKFwiclwiLCA2KTtcbn07XG5jb25zdCBwb2ludCA9IChlbGVtLCB0eXBlLCBpZCkgPT4ge1xuICBlbGVtLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1wb2ludEVuZFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgXCIgKyB0eXBlKS5hdHRyKFwidmlld0JveFwiLCBcIjAgMCAxMCAxMFwiKS5hdHRyKFwicmVmWFwiLCA2KS5hdHRyKFwicmVmWVwiLCA1KS5hdHRyKFwibWFya2VyVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMTIpLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMTIpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDAgMCBMIDEwIDUgTCAwIDEwIHpcIikuYXR0cihcImNsYXNzXCIsIFwiYXJyb3dNYXJrZXJQYXRoXCIpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDEpLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjEsMFwiKTtcbiAgZWxlbS5hcHBlbmQoXCJtYXJrZXJcIikuYXR0cihcImlkXCIsIGlkICsgXCJfXCIgKyB0eXBlICsgXCItcG9pbnRTdGFydFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgXCIgKyB0eXBlKS5hdHRyKFwidmlld0JveFwiLCBcIjAgMCAxMCAxMFwiKS5hdHRyKFwicmVmWFwiLCA0LjUpLmF0dHIoXCJyZWZZXCIsIDUpLmF0dHIoXCJtYXJrZXJVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAxMikuYXR0cihcIm1hcmtlckhlaWdodFwiLCAxMikuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIikuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiZFwiLCBcIk0gMCA1IEwgMTAgMTAgTCAxMCAwIHpcIikuYXR0cihcImNsYXNzXCIsIFwiYXJyb3dNYXJrZXJQYXRoXCIpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDEpLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjEsMFwiKTtcbn07XG5jb25zdCBjaXJjbGUkMSA9IChlbGVtLCB0eXBlLCBpZCkgPT4ge1xuICBlbGVtLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1jaXJjbGVFbmRcIikuYXR0cihcImNsYXNzXCIsIFwibWFya2VyIFwiICsgdHlwZSkuYXR0cihcInZpZXdCb3hcIiwgXCIwIDAgMTAgMTBcIikuYXR0cihcInJlZlhcIiwgMTEpLmF0dHIoXCJyZWZZXCIsIDUpLmF0dHIoXCJtYXJrZXJVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAxMSkuYXR0cihcIm1hcmtlckhlaWdodFwiLCAxMSkuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIikuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJjeFwiLCBcIjVcIikuYXR0cihcImN5XCIsIFwiNVwiKS5hdHRyKFwiclwiLCBcIjVcIikuYXR0cihcImNsYXNzXCIsIFwiYXJyb3dNYXJrZXJQYXRoXCIpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDEpLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjEsMFwiKTtcbiAgZWxlbS5hcHBlbmQoXCJtYXJrZXJcIikuYXR0cihcImlkXCIsIGlkICsgXCJfXCIgKyB0eXBlICsgXCItY2lyY2xlU3RhcnRcIikuYXR0cihcImNsYXNzXCIsIFwibWFya2VyIFwiICsgdHlwZSkuYXR0cihcInZpZXdCb3hcIiwgXCIwIDAgMTAgMTBcIikuYXR0cihcInJlZlhcIiwgLTEpLmF0dHIoXCJyZWZZXCIsIDUpLmF0dHIoXCJtYXJrZXJVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAxMSkuYXR0cihcIm1hcmtlckhlaWdodFwiLCAxMSkuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIikuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJjeFwiLCBcIjVcIikuYXR0cihcImN5XCIsIFwiNVwiKS5hdHRyKFwiclwiLCBcIjVcIikuYXR0cihcImNsYXNzXCIsIFwiYXJyb3dNYXJrZXJQYXRoXCIpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDEpLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjEsMFwiKTtcbn07XG5jb25zdCBjcm9zcyA9IChlbGVtLCB0eXBlLCBpZCkgPT4ge1xuICBlbGVtLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1jcm9zc0VuZFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrZXIgY3Jvc3MgXCIgKyB0eXBlKS5hdHRyKFwidmlld0JveFwiLCBcIjAgMCAxMSAxMVwiKS5hdHRyKFwicmVmWFwiLCAxMikuYXR0cihcInJlZllcIiwgNS4yKS5hdHRyKFwibWFya2VyVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMTEpLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMTEpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5XCIpLmF0dHIoXCJjbGFzc1wiLCBcImFycm93TWFya2VyUGF0aFwiKS5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyKS5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCIxLDBcIik7XG4gIGVsZW0uYXBwZW5kKFwibWFya2VyXCIpLmF0dHIoXCJpZFwiLCBpZCArIFwiX1wiICsgdHlwZSArIFwiLWNyb3NzU3RhcnRcIikuYXR0cihcImNsYXNzXCIsIFwibWFya2VyIGNyb3NzIFwiICsgdHlwZSkuYXR0cihcInZpZXdCb3hcIiwgXCIwIDAgMTEgMTFcIikuYXR0cihcInJlZlhcIiwgLTEpLmF0dHIoXCJyZWZZXCIsIDUuMikuYXR0cihcIm1hcmtlclVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIikuYXR0cihcIm1hcmtlcldpZHRoXCIsIDExKS5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDExKS5hdHRyKFwib3JpZW50XCIsIFwiYXV0b1wiKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJkXCIsIFwiTSAxLDEgbCA5LDkgTSAxMCwxIGwgLTksOVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJhcnJvd01hcmtlclBhdGhcIikuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMikuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMSwwXCIpO1xufTtcbmNvbnN0IGJhcmIgPSAoZWxlbSwgdHlwZSwgaWQpID0+IHtcbiAgZWxlbS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgaWQgKyBcIl9cIiArIHR5cGUgKyBcIi1iYXJiRW5kXCIpLmF0dHIoXCJyZWZYXCIsIDE5KS5hdHRyKFwicmVmWVwiLCA3KS5hdHRyKFwibWFya2VyV2lkdGhcIiwgMjApLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMTQpLmF0dHIoXCJtYXJrZXJVbml0c1wiLCBcInN0cm9rZVdpZHRoXCIpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNIDE5LDcgTDksMTMgTDE0LDcgTDksMSBaXCIpO1xufTtcbmNvbnN0IG1hcmtlcnMgPSB7XG4gIGV4dGVuc2lvbixcbiAgY29tcG9zaXRpb24sXG4gIGFnZ3JlZ2F0aW9uLFxuICBkZXBlbmRlbmN5LFxuICBsb2xsaXBvcCxcbiAgcG9pbnQsXG4gIGNpcmNsZTogY2lyY2xlJDEsXG4gIGNyb3NzLFxuICBiYXJiXG59O1xuY29uc3QgaW5zZXJ0TWFya2VycyQxID0gaW5zZXJ0TWFya2VycztcbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZG9tLCBzdHlsZUZuKSB7XG4gIGlmIChzdHlsZUZuKSB7XG4gICAgZG9tLmF0dHIoXCJzdHlsZVwiLCBzdHlsZUZuKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSHRtbExhYmVsKG5vZGUpIHtcbiAgY29uc3QgZm8gPSBzZWxlY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJmb3JlaWduT2JqZWN0XCIpKTtcbiAgY29uc3QgZGl2ID0gZm8uYXBwZW5kKFwieGh0bWw6ZGl2XCIpO1xuICBjb25zdCBsYWJlbCA9IG5vZGUubGFiZWw7XG4gIGNvbnN0IGxhYmVsQ2xhc3MgPSBub2RlLmlzTm9kZSA/IFwibm9kZUxhYmVsXCIgOiBcImVkZ2VMYWJlbFwiO1xuICBkaXYuaHRtbChcbiAgICAnPHNwYW4gY2xhc3M9XCInICsgbGFiZWxDbGFzcyArICdcIiAnICsgKG5vZGUubGFiZWxTdHlsZSA/ICdzdHlsZT1cIicgKyBub2RlLmxhYmVsU3R5bGUgKyAnXCInIDogXCJcIikgKyBcIj5cIiArIGxhYmVsICsgXCI8L3NwYW4+XCJcbiAgKTtcbiAgYXBwbHlTdHlsZShkaXYsIG5vZGUubGFiZWxTdHlsZSk7XG4gIGRpdi5zdHlsZShcImRpc3BsYXlcIiwgXCJpbmxpbmUtYmxvY2tcIik7XG4gIGRpdi5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwibm93cmFwXCIpO1xuICBkaXYuYXR0cihcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKTtcbiAgcmV0dXJuIGZvLm5vZGUoKTtcbn1cbmNvbnN0IGNyZWF0ZUxhYmVsID0gKF92ZXJ0ZXhUZXh0LCBzdHlsZSwgaXNUaXRsZSwgaXNOb2RlKSA9PiB7XG4gIGxldCB2ZXJ0ZXhUZXh0ID0gX3ZlcnRleFRleHQgfHwgXCJcIjtcbiAgaWYgKHR5cGVvZiB2ZXJ0ZXhUZXh0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmVydGV4VGV4dCA9IHZlcnRleFRleHRbMF07XG4gIH1cbiAgaWYgKGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSkge1xuICAgIHZlcnRleFRleHQgPSB2ZXJ0ZXhUZXh0LnJlcGxhY2UoL1xcXFxufFxcbi9nLCBcIjxiciAvPlwiKTtcbiAgICBsb2cuZGVidWcoXCJ2ZXJ0ZXhUZXh0XCIgKyB2ZXJ0ZXhUZXh0KTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgaXNOb2RlLFxuICAgICAgbGFiZWw6IGRlY29kZUVudGl0aWVzKHZlcnRleFRleHQpLnJlcGxhY2UoXG4gICAgICAgIC9mYVtibHJzXT86ZmEtW1xcdy1dKy9nLFxuICAgICAgICAvLyBjc3BlbGw6IGRpc2FibGUtbGluZVxuICAgICAgICAocykgPT4gYDxpIGNsYXNzPScke3MucmVwbGFjZShcIjpcIiwgXCIgXCIpfSc+PC9pPmBcbiAgICAgICksXG4gICAgICBsYWJlbFN0eWxlOiBzdHlsZS5yZXBsYWNlKFwiZmlsbDpcIiwgXCJjb2xvcjpcIilcbiAgICB9O1xuICAgIGxldCB2ZXJ0ZXhOb2RlID0gYWRkSHRtbExhYmVsKG5vZGUpO1xuICAgIHJldHVybiB2ZXJ0ZXhOb2RlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN2Z0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0ZXh0XCIpO1xuICAgIHN2Z0xhYmVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHN0eWxlLnJlcGxhY2UoXCJjb2xvcjpcIiwgXCJmaWxsOlwiKSk7XG4gICAgbGV0IHJvd3MgPSBbXTtcbiAgICBpZiAodHlwZW9mIHZlcnRleFRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJvd3MgPSB2ZXJ0ZXhUZXh0LnNwbGl0KC9cXFxcbnxcXG58PGJyXFxzKlxcLz8+L2dpKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmVydGV4VGV4dCkpIHtcbiAgICAgIHJvd3MgPSB2ZXJ0ZXhUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByb3dzID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgIGNvbnN0IHRzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0c3BhblwiKTtcbiAgICAgIHRzcGFuLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsIFwieG1sOnNwYWNlXCIsIFwicHJlc2VydmVcIik7XG4gICAgICB0c3Bhbi5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBcIjFlbVwiKTtcbiAgICAgIHRzcGFuLnNldEF0dHJpYnV0ZShcInhcIiwgXCIwXCIpO1xuICAgICAgaWYgKGlzVGl0bGUpIHtcbiAgICAgICAgdHNwYW4uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ0aXRsZS1yb3dcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0c3Bhbi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInJvd1wiKTtcbiAgICAgIH1cbiAgICAgIHRzcGFuLnRleHRDb250ZW50ID0gcm93LnRyaW0oKTtcbiAgICAgIHN2Z0xhYmVsLmFwcGVuZENoaWxkKHRzcGFuKTtcbiAgICB9XG4gICAgcmV0dXJuIHN2Z0xhYmVsO1xuICB9XG59O1xuY29uc3QgY3JlYXRlTGFiZWwkMSA9IGNyZWF0ZUxhYmVsO1xuY29uc3QgbGFiZWxIZWxwZXIgPSBhc3luYyAocGFyZW50LCBub2RlLCBfY2xhc3NlcywgaXNOb2RlKSA9PiB7XG4gIGxldCBjbGFzc2VzO1xuICBjb25zdCB1c2VIdG1sTGFiZWxzID0gbm9kZS51c2VIdG1sTGFiZWxzIHx8IGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKTtcbiAgaWYgKCFfY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBcIm5vZGUgZGVmYXVsdFwiO1xuICB9IGVsc2Uge1xuICAgIGNsYXNzZXMgPSBfY2xhc3NlcztcbiAgfVxuICBjb25zdCBzaGFwZVN2ZyA9IHBhcmVudC5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc2VzKS5hdHRyKFwiaWRcIiwgbm9kZS5kb21JZCB8fCBub2RlLmlkKTtcbiAgY29uc3QgbGFiZWwgPSBzaGFwZVN2Zy5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsXCIpLmF0dHIoXCJzdHlsZVwiLCBub2RlLmxhYmVsU3R5bGUpO1xuICBsZXQgbGFiZWxUZXh0O1xuICBpZiAobm9kZS5sYWJlbFRleHQgPT09IHZvaWQgMCkge1xuICAgIGxhYmVsVGV4dCA9IFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgbGFiZWxUZXh0ID0gdHlwZW9mIG5vZGUubGFiZWxUZXh0ID09PSBcInN0cmluZ1wiID8gbm9kZS5sYWJlbFRleHQgOiBub2RlLmxhYmVsVGV4dFswXTtcbiAgfVxuICBjb25zdCB0ZXh0Tm9kZSA9IGxhYmVsLm5vZGUoKTtcbiAgbGV0IHRleHQ7XG4gIGlmIChub2RlLmxhYmVsVHlwZSA9PT0gXCJtYXJrZG93blwiKSB7XG4gICAgdGV4dCA9IGNyZWF0ZVRleHQobGFiZWwsIHNhbml0aXplVGV4dChkZWNvZGVFbnRpdGllcyhsYWJlbFRleHQpLCBnZXRDb25maWcoKSksIHtcbiAgICAgIHVzZUh0bWxMYWJlbHMsXG4gICAgICB3aWR0aDogbm9kZS53aWR0aCB8fCBnZXRDb25maWcoKS5mbG93Y2hhcnQud3JhcHBpbmdXaWR0aCxcbiAgICAgIGNsYXNzZXM6IFwibWFya2Rvd24tbm9kZS1sYWJlbFwiXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dCA9IHRleHROb2RlLmFwcGVuZENoaWxkKFxuICAgICAgY3JlYXRlTGFiZWwkMShcbiAgICAgICAgc2FuaXRpemVUZXh0KGRlY29kZUVudGl0aWVzKGxhYmVsVGV4dCksIGdldENvbmZpZygpKSxcbiAgICAgICAgbm9kZS5sYWJlbFN0eWxlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgaXNOb2RlXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBsZXQgYmJveCA9IHRleHQuZ2V0QkJveCgpO1xuICBjb25zdCBoYWxmUGFkZGluZyA9IG5vZGUucGFkZGluZyAvIDI7XG4gIGlmIChldmFsdWF0ZShnZXRDb25maWcoKS5mbG93Y2hhcnQuaHRtbExhYmVscykpIHtcbiAgICBjb25zdCBkaXYgPSB0ZXh0LmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGR2ID0gc2VsZWN0KHRleHQpO1xuICAgIGNvbnN0IGltYWdlcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImltZ1wiKTtcbiAgICBpZiAoaW1hZ2VzKSB7XG4gICAgICBjb25zdCBub0ltZ1RleHQgPSBsYWJlbFRleHQucmVwbGFjZSgvPGltZ1tePl0qPi9nLCBcIlwiKS50cmltKCkgPT09IFwiXCI7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgWy4uLmltYWdlc10ubWFwKFxuICAgICAgICAgIChpbWcpID0+IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwSW1hZ2UoKSB7XG4gICAgICAgICAgICAgIGltZy5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICAgICAgICAgIGltZy5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcbiAgICAgICAgICAgICAgaWYgKG5vSW1nVGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlGb250U2l6ZSA9IGdldENvbmZpZygpLmZvbnRTaXplID8gZ2V0Q29uZmlnKCkuZm9udFNpemUgOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5mb250U2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmxhcmdpbmdGYWN0b3IgPSA1O1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQoYm9keUZvbnRTaXplLCAxMCkgKiBlbmxhcmdpbmdGYWN0b3IgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLm1pbldpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLm1heFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzKGltZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHNldHVwSW1hZ2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHNldHVwSW1hZ2UpO1xuICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHNldHVwSW1hZ2UpO1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGJib3ggPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZHYuYXR0cihcIndpZHRoXCIsIGJib3gud2lkdGgpO1xuICAgIGR2LmF0dHIoXCJoZWlnaHRcIiwgYmJveC5oZWlnaHQpO1xuICB9XG4gIGlmICh1c2VIdG1sTGFiZWxzKSB7XG4gICAgbGFiZWwuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1iYm94LndpZHRoIC8gMiArIFwiLCBcIiArIC1iYm94LmhlaWdodCAvIDIgKyBcIilcIik7XG4gIH0gZWxzZSB7XG4gICAgbGFiZWwuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLCBcIiArIC1iYm94LmhlaWdodCAvIDIgKyBcIilcIik7XG4gIH1cbiAgaWYgKG5vZGUuY2VudGVyTGFiZWwpIHtcbiAgICBsYWJlbC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLWJib3gud2lkdGggLyAyICsgXCIsIFwiICsgLWJib3guaGVpZ2h0IC8gMiArIFwiKVwiKTtcbiAgfVxuICBsYWJlbC5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICByZXR1cm4geyBzaGFwZVN2ZywgYmJveCwgaGFsZlBhZGRpbmcsIGxhYmVsIH07XG59O1xuY29uc3QgdXBkYXRlTm9kZUJvdW5kcyA9IChub2RlLCBlbGVtZW50KSA9PiB7XG4gIGNvbnN0IGJib3ggPSBlbGVtZW50Lm5vZGUoKS5nZXRCQm94KCk7XG4gIG5vZGUud2lkdGggPSBiYm94LndpZHRoO1xuICBub2RlLmhlaWdodCA9IGJib3guaGVpZ2h0O1xufTtcbmZ1bmN0aW9uIGluc2VydFBvbHlnb25TaGFwZShwYXJlbnQsIHcsIGgsIHBvaW50cykge1xuICByZXR1cm4gcGFyZW50Lmluc2VydChcInBvbHlnb25cIiwgXCI6Zmlyc3QtY2hpbGRcIikuYXR0cihcbiAgICBcInBvaW50c1wiLFxuICAgIHBvaW50cy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGQueCArIFwiLFwiICsgZC55O1xuICAgIH0pLmpvaW4oXCIgXCIpXG4gICkuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtY29udGFpbmVyXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAtdyAvIDIgKyBcIixcIiArIGggLyAyICsgXCIpXCIpO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0Tm9kZShub2RlLCBwb2ludDIpIHtcbiAgcmV0dXJuIG5vZGUuaW50ZXJzZWN0KHBvaW50Mik7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RFbGxpcHNlKG5vZGUsIHJ4LCByeSwgcG9pbnQyKSB7XG4gIHZhciBjeCA9IG5vZGUueDtcbiAgdmFyIGN5ID0gbm9kZS55O1xuICB2YXIgcHggPSBjeCAtIHBvaW50Mi54O1xuICB2YXIgcHkgPSBjeSAtIHBvaW50Mi55O1xuICB2YXIgZGV0ID0gTWF0aC5zcXJ0KHJ4ICogcnggKiBweSAqIHB5ICsgcnkgKiByeSAqIHB4ICogcHgpO1xuICB2YXIgZHggPSBNYXRoLmFicyhyeCAqIHJ5ICogcHggLyBkZXQpO1xuICBpZiAocG9pbnQyLnggPCBjeCkge1xuICAgIGR4ID0gLWR4O1xuICB9XG4gIHZhciBkeSA9IE1hdGguYWJzKHJ4ICogcnkgKiBweSAvIGRldCk7XG4gIGlmIChwb2ludDIueSA8IGN5KSB7XG4gICAgZHkgPSAtZHk7XG4gIH1cbiAgcmV0dXJuIHsgeDogY3ggKyBkeCwgeTogY3kgKyBkeSB9O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0Q2lyY2xlKG5vZGUsIHJ4LCBwb2ludDIpIHtcbiAgcmV0dXJuIGludGVyc2VjdEVsbGlwc2Uobm9kZSwgcngsIHJ4LCBwb2ludDIpO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0TGluZShwMSwgcDIsIHExLCBxMikge1xuICB2YXIgYTEsIGEyLCBiMSwgYjIsIGMxLCBjMjtcbiAgdmFyIHIxLCByMiwgcjMsIHI0O1xuICB2YXIgZGVub20sIG9mZnNldCwgbnVtO1xuICB2YXIgeCwgeTtcbiAgYTEgPSBwMi55IC0gcDEueTtcbiAgYjEgPSBwMS54IC0gcDIueDtcbiAgYzEgPSBwMi54ICogcDEueSAtIHAxLnggKiBwMi55O1xuICByMyA9IGExICogcTEueCArIGIxICogcTEueSArIGMxO1xuICByNCA9IGExICogcTIueCArIGIxICogcTIueSArIGMxO1xuICBpZiAocjMgIT09IDAgJiYgcjQgIT09IDAgJiYgc2FtZVNpZ24ocjMsIHI0KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhMiA9IHEyLnkgLSBxMS55O1xuICBiMiA9IHExLnggLSBxMi54O1xuICBjMiA9IHEyLnggKiBxMS55IC0gcTEueCAqIHEyLnk7XG4gIHIxID0gYTIgKiBwMS54ICsgYjIgKiBwMS55ICsgYzI7XG4gIHIyID0gYTIgKiBwMi54ICsgYjIgKiBwMi55ICsgYzI7XG4gIGlmIChyMSAhPT0gMCAmJiByMiAhPT0gMCAmJiBzYW1lU2lnbihyMSwgcjIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlbm9tID0gYTEgKiBiMiAtIGEyICogYjE7XG4gIGlmIChkZW5vbSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBvZmZzZXQgPSBNYXRoLmFicyhkZW5vbSAvIDIpO1xuICBudW0gPSBiMSAqIGMyIC0gYjIgKiBjMTtcbiAgeCA9IG51bSA8IDAgPyAobnVtIC0gb2Zmc2V0KSAvIGRlbm9tIDogKG51bSArIG9mZnNldCkgLyBkZW5vbTtcbiAgbnVtID0gYTIgKiBjMSAtIGExICogYzI7XG4gIHkgPSBudW0gPCAwID8gKG51bSAtIG9mZnNldCkgLyBkZW5vbSA6IChudW0gKyBvZmZzZXQpIC8gZGVub207XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cbmZ1bmN0aW9uIHNhbWVTaWduKHIxLCByMikge1xuICByZXR1cm4gcjEgKiByMiA+IDA7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RQb2x5Z29uKG5vZGUsIHBvbHlQb2ludHMsIHBvaW50Mikge1xuICB2YXIgeDEgPSBub2RlLng7XG4gIHZhciB5MSA9IG5vZGUueTtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIHZhciBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBpZiAodHlwZW9mIHBvbHlQb2ludHMuZm9yRWFjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcG9seVBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgZW50cnkueCk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgZW50cnkueSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHBvbHlQb2ludHMueCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHBvbHlQb2ludHMueSk7XG4gIH1cbiAgdmFyIGxlZnQgPSB4MSAtIG5vZGUud2lkdGggLyAyIC0gbWluWDtcbiAgdmFyIHRvcCA9IHkxIC0gbm9kZS5oZWlnaHQgLyAyIC0gbWluWTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5UG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAxID0gcG9seVBvaW50c1tpXTtcbiAgICB2YXIgcDIgPSBwb2x5UG9pbnRzW2kgPCBwb2x5UG9pbnRzLmxlbmd0aCAtIDEgPyBpICsgMSA6IDBdO1xuICAgIHZhciBpbnRlcnNlY3QyID0gaW50ZXJzZWN0TGluZShcbiAgICAgIG5vZGUsXG4gICAgICBwb2ludDIsXG4gICAgICB7IHg6IGxlZnQgKyBwMS54LCB5OiB0b3AgKyBwMS55IH0sXG4gICAgICB7IHg6IGxlZnQgKyBwMi54LCB5OiB0b3AgKyBwMi55IH1cbiAgICApO1xuICAgIGlmIChpbnRlcnNlY3QyKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0Mik7XG4gICAgfVxuICB9XG4gIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgaW50ZXJzZWN0aW9ucy5zb3J0KGZ1bmN0aW9uKHAsIHEpIHtcbiAgICAgIHZhciBwZHggPSBwLnggLSBwb2ludDIueDtcbiAgICAgIHZhciBwZHkgPSBwLnkgLSBwb2ludDIueTtcbiAgICAgIHZhciBkaXN0cCA9IE1hdGguc3FydChwZHggKiBwZHggKyBwZHkgKiBwZHkpO1xuICAgICAgdmFyIHFkeCA9IHEueCAtIHBvaW50Mi54O1xuICAgICAgdmFyIHFkeSA9IHEueSAtIHBvaW50Mi55O1xuICAgICAgdmFyIGRpc3RxID0gTWF0aC5zcXJ0KHFkeCAqIHFkeCArIHFkeSAqIHFkeSk7XG4gICAgICByZXR1cm4gZGlzdHAgPCBkaXN0cSA/IC0xIDogZGlzdHAgPT09IGRpc3RxID8gMCA6IDE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbnNbMF07XG59XG5jb25zdCBpbnRlcnNlY3RSZWN0ID0gKG5vZGUsIHBvaW50MikgPT4ge1xuICB2YXIgeCA9IG5vZGUueDtcbiAgdmFyIHkgPSBub2RlLnk7XG4gIHZhciBkeCA9IHBvaW50Mi54IC0geDtcbiAgdmFyIGR5ID0gcG9pbnQyLnkgLSB5O1xuICB2YXIgdyA9IG5vZGUud2lkdGggLyAyO1xuICB2YXIgaCA9IG5vZGUuaGVpZ2h0IC8gMjtcbiAgdmFyIHN4LCBzeTtcbiAgaWYgKE1hdGguYWJzKGR5KSAqIHcgPiBNYXRoLmFicyhkeCkgKiBoKSB7XG4gICAgaWYgKGR5IDwgMCkge1xuICAgICAgaCA9IC1oO1xuICAgIH1cbiAgICBzeCA9IGR5ID09PSAwID8gMCA6IGggKiBkeCAvIGR5O1xuICAgIHN5ID0gaDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZHggPCAwKSB7XG4gICAgICB3ID0gLXc7XG4gICAgfVxuICAgIHN4ID0gdztcbiAgICBzeSA9IGR4ID09PSAwID8gMCA6IHcgKiBkeSAvIGR4O1xuICB9XG4gIHJldHVybiB7IHg6IHggKyBzeCwgeTogeSArIHN5IH07XG59O1xuY29uc3QgaW50ZXJzZWN0UmVjdCQxID0gaW50ZXJzZWN0UmVjdDtcbmNvbnN0IGludGVyc2VjdCA9IHtcbiAgbm9kZTogaW50ZXJzZWN0Tm9kZSxcbiAgY2lyY2xlOiBpbnRlcnNlY3RDaXJjbGUsXG4gIGVsbGlwc2U6IGludGVyc2VjdEVsbGlwc2UsXG4gIHBvbHlnb246IGludGVyc2VjdFBvbHlnb24sXG4gIHJlY3Q6IGludGVyc2VjdFJlY3QkMVxufTtcbmNvbnN0IG5vdGUgPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHVzZUh0bWxMYWJlbHMgPSBub2RlLnVzZUh0bWxMYWJlbHMgfHwgZ2V0Q29uZmlnKCkuZmxvd2NoYXJ0Lmh0bWxMYWJlbHM7XG4gIGlmICghdXNlSHRtbExhYmVscykge1xuICAgIG5vZGUuY2VudGVyTGFiZWwgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHsgc2hhcGVTdmcsIGJib3gsIGhhbGZQYWRkaW5nIH0gPSBhd2FpdCBsYWJlbEhlbHBlcihcbiAgICBwYXJlbnQsXG4gICAgbm9kZSxcbiAgICBcIm5vZGUgXCIgKyBub2RlLmNsYXNzZXMsXG4gICAgdHJ1ZVxuICApO1xuICBsb2cuaW5mbyhcIkNsYXNzZXMgPSBcIiwgbm9kZS5jbGFzc2VzKTtcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICByZWN0Mi5hdHRyKFwicnhcIiwgbm9kZS5yeCkuYXR0cihcInJ5XCIsIG5vZGUucnkpLmF0dHIoXCJ4XCIsIC1iYm94LndpZHRoIC8gMiAtIGhhbGZQYWRkaW5nKS5hdHRyKFwieVwiLCAtYmJveC5oZWlnaHQgLyAyIC0gaGFsZlBhZGRpbmcpLmF0dHIoXCJ3aWR0aFwiLCBiYm94LndpZHRoICsgbm9kZS5wYWRkaW5nKS5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0ICsgbm9kZS5wYWRkaW5nKTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCByZWN0Mik7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdC5yZWN0KG5vZGUsIHBvaW50Mik7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCBub3RlJDEgPSBub3RlO1xuY29uc3QgZXhwYW5kQW5kRGVkdXBsaWNhdGVEaXJlY3Rpb25zID0gKGRpcmVjdGlvbnMpID0+IHtcbiAgY29uc3QgdW5pcXVlRGlyZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgZGlyZWN0aW9uIG9mIGRpcmVjdGlvbnMpIHtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgdW5pcXVlRGlyZWN0aW9ucy5hZGQoXCJyaWdodFwiKTtcbiAgICAgICAgdW5pcXVlRGlyZWN0aW9ucy5hZGQoXCJsZWZ0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgIHVuaXF1ZURpcmVjdGlvbnMuYWRkKFwidXBcIik7XG4gICAgICAgIHVuaXF1ZURpcmVjdGlvbnMuYWRkKFwiZG93blwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB1bmlxdWVEaXJlY3Rpb25zLmFkZChkaXJlY3Rpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuaXF1ZURpcmVjdGlvbnM7XG59O1xuY29uc3QgZ2V0QXJyb3dQb2ludHMgPSAoZHVwbGljYXRlZERpcmVjdGlvbnMsIGJib3gsIG5vZGUpID0+IHtcbiAgY29uc3QgZGlyZWN0aW9ucyA9IGV4cGFuZEFuZERlZHVwbGljYXRlRGlyZWN0aW9ucyhkdXBsaWNhdGVkRGlyZWN0aW9ucyk7XG4gIGNvbnN0IGYgPSAyO1xuICBjb25zdCBoZWlnaHQgPSBiYm94LmhlaWdodCArIDIgKiBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IG1pZHBvaW50ID0gaGVpZ2h0IC8gZjtcbiAgY29uc3Qgd2lkdGggPSBiYm94LndpZHRoICsgMiAqIG1pZHBvaW50ICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCBwYWRkaW5nID0gbm9kZS5wYWRkaW5nIC8gMjtcbiAgaWYgKGRpcmVjdGlvbnMuaGFzKFwicmlnaHRcIikgJiYgZGlyZWN0aW9ucy5oYXMoXCJsZWZ0XCIpICYmIGRpcmVjdGlvbnMuaGFzKFwidXBcIikgJiYgZGlyZWN0aW9ucy5oYXMoXCJkb3duXCIpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIEJvdHRvbVxuICAgICAgeyB4OiAwLCB5OiAwIH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAwIH0sXG4gICAgICB7IHg6IHdpZHRoIC8gMiwgeTogMiAqIHBhZGRpbmcgfSxcbiAgICAgIHsgeDogd2lkdGggLSBtaWRwb2ludCwgeTogMCB9LFxuICAgICAgeyB4OiB3aWR0aCwgeTogMCB9LFxuICAgICAgLy8gUmlnaHRcbiAgICAgIHsgeDogd2lkdGgsIHk6IC1oZWlnaHQgLyAzIH0sXG4gICAgICB7IHg6IHdpZHRoICsgMiAqIHBhZGRpbmcsIHk6IC1oZWlnaHQgLyAyIH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtMiAqIGhlaWdodCAvIDMgfSxcbiAgICAgIHsgeDogd2lkdGgsIHk6IC1oZWlnaHQgfSxcbiAgICAgIC8vIFRvcFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtaGVpZ2h0IH0sXG4gICAgICB7IHg6IHdpZHRoIC8gMiwgeTogLWhlaWdodCAtIDIgKiBwYWRkaW5nIH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAtaGVpZ2h0IH0sXG4gICAgICAvLyBMZWZ0XG4gICAgICB7IHg6IDAsIHk6IC1oZWlnaHQgfSxcbiAgICAgIHsgeDogMCwgeTogLTIgKiBoZWlnaHQgLyAzIH0sXG4gICAgICB7IHg6IC0yICogcGFkZGluZywgeTogLWhlaWdodCAvIDIgfSxcbiAgICAgIHsgeDogMCwgeTogLWhlaWdodCAvIDMgfVxuICAgIF07XG4gIH1cbiAgaWYgKGRpcmVjdGlvbnMuaGFzKFwicmlnaHRcIikgJiYgZGlyZWN0aW9ucy5oYXMoXCJsZWZ0XCIpICYmIGRpcmVjdGlvbnMuaGFzKFwidXBcIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiBtaWRwb2ludCwgeTogMCB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAwIH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtaGVpZ2h0IC8gMiB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtaGVpZ2h0IH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAtaGVpZ2h0IH0sXG4gICAgICB7IHg6IDAsIHk6IC1oZWlnaHQgLyAyIH1cbiAgICBdO1xuICB9XG4gIGlmIChkaXJlY3Rpb25zLmhhcyhcInJpZ2h0XCIpICYmIGRpcmVjdGlvbnMuaGFzKFwibGVmdFwiKSAmJiBkaXJlY3Rpb25zLmhhcyhcImRvd25cIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiAwLCB5OiAwIH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAtaGVpZ2h0IH0sXG4gICAgICB7IHg6IHdpZHRoIC0gbWlkcG9pbnQsIHk6IC1oZWlnaHQgfSxcbiAgICAgIHsgeDogd2lkdGgsIHk6IDAgfVxuICAgIF07XG4gIH1cbiAgaWYgKGRpcmVjdGlvbnMuaGFzKFwicmlnaHRcIikgJiYgZGlyZWN0aW9ucy5oYXMoXCJ1cFwiKSAmJiBkaXJlY3Rpb25zLmhhcyhcImRvd25cIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiAwLCB5OiAwIH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtbWlkcG9pbnQgfSxcbiAgICAgIHsgeDogd2lkdGgsIHk6IC1oZWlnaHQgKyBtaWRwb2ludCB9LFxuICAgICAgeyB4OiAwLCB5OiAtaGVpZ2h0IH1cbiAgICBdO1xuICB9XG4gIGlmIChkaXJlY3Rpb25zLmhhcyhcImxlZnRcIikgJiYgZGlyZWN0aW9ucy5oYXMoXCJ1cFwiKSAmJiBkaXJlY3Rpb25zLmhhcyhcImRvd25cIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiB3aWR0aCwgeTogMCB9LFxuICAgICAgeyB4OiAwLCB5OiAtbWlkcG9pbnQgfSxcbiAgICAgIHsgeDogMCwgeTogLWhlaWdodCArIG1pZHBvaW50IH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtaGVpZ2h0IH1cbiAgICBdO1xuICB9XG4gIGlmIChkaXJlY3Rpb25zLmhhcyhcInJpZ2h0XCIpICYmIGRpcmVjdGlvbnMuaGFzKFwibGVmdFwiKSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAwIH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAtcGFkZGluZyB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtcGFkZGluZyB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAwIH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtaGVpZ2h0IC8gMiB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtaGVpZ2h0IH0sXG4gICAgICB7IHg6IHdpZHRoIC0gbWlkcG9pbnQsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAtaGVpZ2h0ICsgcGFkZGluZyB9LFxuICAgICAgeyB4OiBtaWRwb2ludCwgeTogLWhlaWdodCB9LFxuICAgICAgeyB4OiAwLCB5OiAtaGVpZ2h0IC8gMiB9XG4gICAgXTtcbiAgfVxuICBpZiAoZGlyZWN0aW9ucy5oYXMoXCJ1cFwiKSAmJiBkaXJlY3Rpb25zLmhhcyhcImRvd25cIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQm90dG9tIGNlbnRlclxuICAgICAgeyB4OiB3aWR0aCAvIDIsIHk6IDAgfSxcbiAgICAgIC8vIExlZnQgcG9udCBvZiBib3R0b20gYXJyb3dcbiAgICAgIHsgeDogMCwgeTogLXBhZGRpbmcgfSxcbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1wYWRkaW5nIH0sXG4gICAgICAvLyBMZWZ0IHRvcCBvdmVyIHZlcnRpY2FsIHNlY3Rpb25cbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICB7IHg6IDAsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICAvLyBUb3Agb2YgYXJyb3dcbiAgICAgIHsgeDogd2lkdGggLyAyLCB5OiAtaGVpZ2h0IH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtaGVpZ2h0ICsgcGFkZGluZyB9LFxuICAgICAgLy8gVG9wIG9mIHJpZ2h0IHZlcnRpY2FsIGJhclxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtaGVpZ2h0ICsgcGFkZGluZyB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtcGFkZGluZyB9LFxuICAgICAgeyB4OiB3aWR0aCwgeTogLXBhZGRpbmcgfVxuICAgIF07XG4gIH1cbiAgaWYgKGRpcmVjdGlvbnMuaGFzKFwicmlnaHRcIikgJiYgZGlyZWN0aW9ucy5oYXMoXCJ1cFwiKSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IDAsIHk6IDAgfSxcbiAgICAgIHsgeDogd2lkdGgsIHk6IC1taWRwb2ludCB9LFxuICAgICAgeyB4OiAwLCB5OiAtaGVpZ2h0IH1cbiAgICBdO1xuICB9XG4gIGlmIChkaXJlY3Rpb25zLmhhcyhcInJpZ2h0XCIpICYmIGRpcmVjdGlvbnMuaGFzKFwiZG93blwiKSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IDAsIHk6IDAgfSxcbiAgICAgIHsgeDogd2lkdGgsIHk6IDAgfSxcbiAgICAgIHsgeDogMCwgeTogLWhlaWdodCB9XG4gICAgXTtcbiAgfVxuICBpZiAoZGlyZWN0aW9ucy5oYXMoXCJsZWZ0XCIpICYmIGRpcmVjdGlvbnMuaGFzKFwidXBcIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiB3aWR0aCwgeTogMCB9LFxuICAgICAgeyB4OiAwLCB5OiAtbWlkcG9pbnQgfSxcbiAgICAgIHsgeDogd2lkdGgsIHk6IC1oZWlnaHQgfVxuICAgIF07XG4gIH1cbiAgaWYgKGRpcmVjdGlvbnMuaGFzKFwibGVmdFwiKSAmJiBkaXJlY3Rpb25zLmhhcyhcImRvd25cIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB4OiB3aWR0aCwgeTogMCB9LFxuICAgICAgeyB4OiAwLCB5OiAwIH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtaGVpZ2h0IH1cbiAgICBdO1xuICB9XG4gIGlmIChkaXJlY3Rpb25zLmhhcyhcInJpZ2h0XCIpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1wYWRkaW5nIH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAtcGFkZGluZyB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtcGFkZGluZyB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAwIH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtaGVpZ2h0IC8gMiB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtaGVpZ2h0IH0sXG4gICAgICB7IHg6IHdpZHRoIC0gbWlkcG9pbnQsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICAvLyB0b3AgbGVmdCBjb3JuZXIgb2YgYXJyb3dcbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICB7IHg6IG1pZHBvaW50LCB5OiAtaGVpZ2h0ICsgcGFkZGluZyB9XG4gICAgXTtcbiAgfVxuICBpZiAoZGlyZWN0aW9ucy5oYXMoXCJsZWZ0XCIpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IDAgfSxcbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1wYWRkaW5nIH0sXG4gICAgICAvLyBUd28gcG9pbnRzLCB0aGUgcmlnaHQgY29ybmVyc1xuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtcGFkZGluZyB9LFxuICAgICAgeyB4OiB3aWR0aCAtIG1pZHBvaW50LCB5OiAtaGVpZ2h0ICsgcGFkZGluZyB9LFxuICAgICAgeyB4OiBtaWRwb2ludCwgeTogLWhlaWdodCArIHBhZGRpbmcgfSxcbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1oZWlnaHQgfSxcbiAgICAgIHsgeDogMCwgeTogLWhlaWdodCAvIDIgfVxuICAgIF07XG4gIH1cbiAgaWYgKGRpcmVjdGlvbnMuaGFzKFwidXBcIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQm90dG9tIGNlbnRlclxuICAgICAgeyB4OiBtaWRwb2ludCwgeTogLXBhZGRpbmcgfSxcbiAgICAgIC8vIExlZnQgdG9wIG92ZXIgdmVydGljYWwgc2VjdGlvblxuICAgICAgeyB4OiBtaWRwb2ludCwgeTogLWhlaWdodCArIHBhZGRpbmcgfSxcbiAgICAgIHsgeDogMCwgeTogLWhlaWdodCArIHBhZGRpbmcgfSxcbiAgICAgIC8vIFRvcCBvZiBhcnJvd1xuICAgICAgeyB4OiB3aWR0aCAvIDIsIHk6IC1oZWlnaHQgfSxcbiAgICAgIHsgeDogd2lkdGgsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICAvLyBUb3Agb2YgcmlnaHQgdmVydGljYWwgYmFyXG4gICAgICB7IHg6IHdpZHRoIC0gbWlkcG9pbnQsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICB7IHg6IHdpZHRoIC0gbWlkcG9pbnQsIHk6IC1wYWRkaW5nIH1cbiAgICBdO1xuICB9XG4gIGlmIChkaXJlY3Rpb25zLmhhcyhcImRvd25cIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQm90dG9tIGNlbnRlclxuICAgICAgeyB4OiB3aWR0aCAvIDIsIHk6IDAgfSxcbiAgICAgIC8vIExlZnQgcG9udCBvZiBib3R0b20gYXJyb3dcbiAgICAgIHsgeDogMCwgeTogLXBhZGRpbmcgfSxcbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1wYWRkaW5nIH0sXG4gICAgICAvLyBMZWZ0IHRvcCBvdmVyIHZlcnRpY2FsIHNlY3Rpb25cbiAgICAgIHsgeDogbWlkcG9pbnQsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICB7IHg6IHdpZHRoIC0gbWlkcG9pbnQsIHk6IC1oZWlnaHQgKyBwYWRkaW5nIH0sXG4gICAgICB7IHg6IHdpZHRoIC0gbWlkcG9pbnQsIHk6IC1wYWRkaW5nIH0sXG4gICAgICB7IHg6IHdpZHRoLCB5OiAtcGFkZGluZyB9XG4gICAgXTtcbiAgfVxuICByZXR1cm4gW3sgeDogMCwgeTogMCB9XTtcbn07XG5jb25zdCBmb3JtYXRDbGFzcyA9IChzdHIpID0+IHtcbiAgaWYgKHN0cikge1xuICAgIHJldHVybiBcIiBcIiArIHN0cjtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn07XG5jb25zdCBnZXRDbGFzc2VzRnJvbU5vZGUgPSAobm9kZSwgb3RoZXJDbGFzc2VzKSA9PiB7XG4gIHJldHVybiBgJHtvdGhlckNsYXNzZXMgPyBvdGhlckNsYXNzZXMgOiBcIm5vZGUgZGVmYXVsdFwifSR7Zm9ybWF0Q2xhc3Mobm9kZS5jbGFzc2VzKX0gJHtmb3JtYXRDbGFzcyhcbiAgICBub2RlLmNsYXNzXG4gICl9YDtcbn07XG5jb25zdCBxdWVzdGlvbiA9IGFzeW5jIChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3QgeyBzaGFwZVN2ZywgYmJveCB9ID0gYXdhaXQgbGFiZWxIZWxwZXIoXG4gICAgcGFyZW50LFxuICAgIG5vZGUsXG4gICAgZ2V0Q2xhc3Nlc0Zyb21Ob2RlKG5vZGUsIHZvaWQgMCksXG4gICAgdHJ1ZVxuICApO1xuICBjb25zdCB3ID0gYmJveC53aWR0aCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgaCA9IGJib3guaGVpZ2h0ICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCBzID0gdyArIGg7XG4gIGNvbnN0IHBvaW50cyA9IFtcbiAgICB7IHg6IHMgLyAyLCB5OiAwIH0sXG4gICAgeyB4OiBzLCB5OiAtcyAvIDIgfSxcbiAgICB7IHg6IHMgLyAyLCB5OiAtcyB9LFxuICAgIHsgeDogMCwgeTogLXMgLyAyIH1cbiAgXTtcbiAgbG9nLmluZm8oXCJRdWVzdGlvbiBtYWluIChDaXJjbGUpXCIpO1xuICBjb25zdCBxdWVzdGlvbkVsZW0gPSBpbnNlcnRQb2x5Z29uU2hhcGUoc2hhcGVTdmcsIHMsIHMsIHBvaW50cyk7XG4gIHF1ZXN0aW9uRWxlbS5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSk7XG4gIHVwZGF0ZU5vZGVCb3VuZHMobm9kZSwgcXVlc3Rpb25FbGVtKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICBsb2cud2FybihcIkludGVyc2VjdCBjYWxsZWRcIik7XG4gICAgcmV0dXJuIGludGVyc2VjdC5wb2x5Z29uKG5vZGUsIHBvaW50cywgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IGNob2ljZSA9IChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3Qgc2hhcGVTdmcgPSBwYXJlbnQuaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlIGRlZmF1bHRcIikuYXR0cihcImlkXCIsIG5vZGUuZG9tSWQgfHwgbm9kZS5pZCk7XG4gIGNvbnN0IHMgPSAyODtcbiAgY29uc3QgcG9pbnRzID0gW1xuICAgIHsgeDogMCwgeTogcyAvIDIgfSxcbiAgICB7IHg6IHMgLyAyLCB5OiAwIH0sXG4gICAgeyB4OiAwLCB5OiAtcyAvIDIgfSxcbiAgICB7IHg6IC1zIC8gMiwgeTogMCB9XG4gIF07XG4gIGNvbnN0IGNob2ljZTIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJwb2x5Z29uXCIsIFwiOmZpcnN0LWNoaWxkXCIpLmF0dHIoXG4gICAgXCJwb2ludHNcIixcbiAgICBwb2ludHMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBkLnggKyBcIixcIiArIGQueTtcbiAgICB9KS5qb2luKFwiIFwiKVxuICApO1xuICBjaG9pY2UyLmF0dHIoXCJjbGFzc1wiLCBcInN0YXRlLXN0YXJ0XCIpLmF0dHIoXCJyXCIsIDcpLmF0dHIoXCJ3aWR0aFwiLCAyOCkuYXR0cihcImhlaWdodFwiLCAyOCk7XG4gIG5vZGUud2lkdGggPSAyODtcbiAgbm9kZS5oZWlnaHQgPSAyODtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LmNpcmNsZShub2RlLCAxNCwgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IGhleGFnb24gPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHsgc2hhcGVTdmcsIGJib3ggfSA9IGF3YWl0IGxhYmVsSGVscGVyKFxuICAgIHBhcmVudCxcbiAgICBub2RlLFxuICAgIGdldENsYXNzZXNGcm9tTm9kZShub2RlLCB2b2lkIDApLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgZiA9IDQ7XG4gIGNvbnN0IGggPSBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgbSA9IGggLyBmO1xuICBjb25zdCB3ID0gYmJveC53aWR0aCArIDIgKiBtICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCBwb2ludHMgPSBbXG4gICAgeyB4OiBtLCB5OiAwIH0sXG4gICAgeyB4OiB3IC0gbSwgeTogMCB9LFxuICAgIHsgeDogdywgeTogLWggLyAyIH0sXG4gICAgeyB4OiB3IC0gbSwgeTogLWggfSxcbiAgICB7IHg6IG0sIHk6IC1oIH0sXG4gICAgeyB4OiAwLCB5OiAtaCAvIDIgfVxuICBdO1xuICBjb25zdCBoZXggPSBpbnNlcnRQb2x5Z29uU2hhcGUoc2hhcGVTdmcsIHcsIGgsIHBvaW50cyk7XG4gIGhleC5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSk7XG4gIHVwZGF0ZU5vZGVCb3VuZHMobm9kZSwgaGV4KTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LnBvbHlnb24obm9kZSwgcG9pbnRzLCBwb2ludDIpO1xuICB9O1xuICByZXR1cm4gc2hhcGVTdmc7XG59O1xuY29uc3QgYmxvY2tfYXJyb3cgPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHsgc2hhcGVTdmcsIGJib3ggfSA9IGF3YWl0IGxhYmVsSGVscGVyKHBhcmVudCwgbm9kZSwgdm9pZCAwLCB0cnVlKTtcbiAgY29uc3QgZiA9IDI7XG4gIGNvbnN0IGggPSBiYm94LmhlaWdodCArIDIgKiBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IG0gPSBoIC8gZjtcbiAgY29uc3QgdyA9IGJib3gud2lkdGggKyAyICogbSArIG5vZGUucGFkZGluZztcbiAgY29uc3QgcG9pbnRzID0gZ2V0QXJyb3dQb2ludHMobm9kZS5kaXJlY3Rpb25zLCBiYm94LCBub2RlKTtcbiAgY29uc3QgYmxvY2tBcnJvdyA9IGluc2VydFBvbHlnb25TaGFwZShzaGFwZVN2ZywgdywgaCwgcG9pbnRzKTtcbiAgYmxvY2tBcnJvdy5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSk7XG4gIHVwZGF0ZU5vZGVCb3VuZHMobm9kZSwgYmxvY2tBcnJvdyk7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdC5wb2x5Z29uKG5vZGUsIHBvaW50cywgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IHJlY3RfbGVmdF9pbnZfYXJyb3cgPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHsgc2hhcGVTdmcsIGJib3ggfSA9IGF3YWl0IGxhYmVsSGVscGVyKFxuICAgIHBhcmVudCxcbiAgICBub2RlLFxuICAgIGdldENsYXNzZXNGcm9tTm9kZShub2RlLCB2b2lkIDApLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgdyA9IGJib3gud2lkdGggKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IGggPSBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgcG9pbnRzID0gW1xuICAgIHsgeDogLWggLyAyLCB5OiAwIH0sXG4gICAgeyB4OiB3LCB5OiAwIH0sXG4gICAgeyB4OiB3LCB5OiAtaCB9LFxuICAgIHsgeDogLWggLyAyLCB5OiAtaCB9LFxuICAgIHsgeDogMCwgeTogLWggLyAyIH1cbiAgXTtcbiAgY29uc3QgZWwgPSBpbnNlcnRQb2x5Z29uU2hhcGUoc2hhcGVTdmcsIHcsIGgsIHBvaW50cyk7XG4gIGVsLmF0dHIoXCJzdHlsZVwiLCBub2RlLnN0eWxlKTtcbiAgbm9kZS53aWR0aCA9IHcgKyBoO1xuICBub2RlLmhlaWdodCA9IGg7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdC5wb2x5Z29uKG5vZGUsIHBvaW50cywgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IGxlYW5fcmlnaHQgPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHsgc2hhcGVTdmcsIGJib3ggfSA9IGF3YWl0IGxhYmVsSGVscGVyKHBhcmVudCwgbm9kZSwgZ2V0Q2xhc3Nlc0Zyb21Ob2RlKG5vZGUpLCB0cnVlKTtcbiAgY29uc3QgdyA9IGJib3gud2lkdGggKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IGggPSBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgcG9pbnRzID0gW1xuICAgIHsgeDogLTIgKiBoIC8gNiwgeTogMCB9LFxuICAgIHsgeDogdyAtIGggLyA2LCB5OiAwIH0sXG4gICAgeyB4OiB3ICsgMiAqIGggLyA2LCB5OiAtaCB9LFxuICAgIHsgeDogaCAvIDYsIHk6IC1oIH1cbiAgXTtcbiAgY29uc3QgZWwgPSBpbnNlcnRQb2x5Z29uU2hhcGUoc2hhcGVTdmcsIHcsIGgsIHBvaW50cyk7XG4gIGVsLmF0dHIoXCJzdHlsZVwiLCBub2RlLnN0eWxlKTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCBlbCk7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdC5wb2x5Z29uKG5vZGUsIHBvaW50cywgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IGxlYW5fbGVmdCA9IGFzeW5jIChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3QgeyBzaGFwZVN2ZywgYmJveCB9ID0gYXdhaXQgbGFiZWxIZWxwZXIoXG4gICAgcGFyZW50LFxuICAgIG5vZGUsXG4gICAgZ2V0Q2xhc3Nlc0Zyb21Ob2RlKG5vZGUsIHZvaWQgMCksXG4gICAgdHJ1ZVxuICApO1xuICBjb25zdCB3ID0gYmJveC53aWR0aCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgaCA9IGJib3guaGVpZ2h0ICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCBwb2ludHMgPSBbXG4gICAgeyB4OiAyICogaCAvIDYsIHk6IDAgfSxcbiAgICB7IHg6IHcgKyBoIC8gNiwgeTogMCB9LFxuICAgIHsgeDogdyAtIDIgKiBoIC8gNiwgeTogLWggfSxcbiAgICB7IHg6IC1oIC8gNiwgeTogLWggfVxuICBdO1xuICBjb25zdCBlbCA9IGluc2VydFBvbHlnb25TaGFwZShzaGFwZVN2ZywgdywgaCwgcG9pbnRzKTtcbiAgZWwuYXR0cihcInN0eWxlXCIsIG5vZGUuc3R5bGUpO1xuICB1cGRhdGVOb2RlQm91bmRzKG5vZGUsIGVsKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LnBvbHlnb24obm9kZSwgcG9pbnRzLCBwb2ludDIpO1xuICB9O1xuICByZXR1cm4gc2hhcGVTdmc7XG59O1xuY29uc3QgdHJhcGV6b2lkID0gYXN5bmMgKHBhcmVudCwgbm9kZSkgPT4ge1xuICBjb25zdCB7IHNoYXBlU3ZnLCBiYm94IH0gPSBhd2FpdCBsYWJlbEhlbHBlcihcbiAgICBwYXJlbnQsXG4gICAgbm9kZSxcbiAgICBnZXRDbGFzc2VzRnJvbU5vZGUobm9kZSwgdm9pZCAwKSxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IHcgPSBiYm94LndpZHRoICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCBoID0gYmJveC5oZWlnaHQgKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IHBvaW50cyA9IFtcbiAgICB7IHg6IC0yICogaCAvIDYsIHk6IDAgfSxcbiAgICB7IHg6IHcgKyAyICogaCAvIDYsIHk6IDAgfSxcbiAgICB7IHg6IHcgLSBoIC8gNiwgeTogLWggfSxcbiAgICB7IHg6IGggLyA2LCB5OiAtaCB9XG4gIF07XG4gIGNvbnN0IGVsID0gaW5zZXJ0UG9seWdvblNoYXBlKHNoYXBlU3ZnLCB3LCBoLCBwb2ludHMpO1xuICBlbC5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSk7XG4gIHVwZGF0ZU5vZGVCb3VuZHMobm9kZSwgZWwpO1xuICBub2RlLmludGVyc2VjdCA9IGZ1bmN0aW9uKHBvaW50Mikge1xuICAgIHJldHVybiBpbnRlcnNlY3QucG9seWdvbihub2RlLCBwb2ludHMsIHBvaW50Mik7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCBpbnZfdHJhcGV6b2lkID0gYXN5bmMgKHBhcmVudCwgbm9kZSkgPT4ge1xuICBjb25zdCB7IHNoYXBlU3ZnLCBiYm94IH0gPSBhd2FpdCBsYWJlbEhlbHBlcihcbiAgICBwYXJlbnQsXG4gICAgbm9kZSxcbiAgICBnZXRDbGFzc2VzRnJvbU5vZGUobm9kZSwgdm9pZCAwKSxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IHcgPSBiYm94LndpZHRoICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCBoID0gYmJveC5oZWlnaHQgKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IHBvaW50cyA9IFtcbiAgICB7IHg6IGggLyA2LCB5OiAwIH0sXG4gICAgeyB4OiB3IC0gaCAvIDYsIHk6IDAgfSxcbiAgICB7IHg6IHcgKyAyICogaCAvIDYsIHk6IC1oIH0sXG4gICAgeyB4OiAtMiAqIGggLyA2LCB5OiAtaCB9XG4gIF07XG4gIGNvbnN0IGVsID0gaW5zZXJ0UG9seWdvblNoYXBlKHNoYXBlU3ZnLCB3LCBoLCBwb2ludHMpO1xuICBlbC5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSk7XG4gIHVwZGF0ZU5vZGVCb3VuZHMobm9kZSwgZWwpO1xuICBub2RlLmludGVyc2VjdCA9IGZ1bmN0aW9uKHBvaW50Mikge1xuICAgIHJldHVybiBpbnRlcnNlY3QucG9seWdvbihub2RlLCBwb2ludHMsIHBvaW50Mik7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCByZWN0X3JpZ2h0X2ludl9hcnJvdyA9IGFzeW5jIChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3QgeyBzaGFwZVN2ZywgYmJveCB9ID0gYXdhaXQgbGFiZWxIZWxwZXIoXG4gICAgcGFyZW50LFxuICAgIG5vZGUsXG4gICAgZ2V0Q2xhc3Nlc0Zyb21Ob2RlKG5vZGUsIHZvaWQgMCksXG4gICAgdHJ1ZVxuICApO1xuICBjb25zdCB3ID0gYmJveC53aWR0aCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgaCA9IGJib3guaGVpZ2h0ICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCBwb2ludHMgPSBbXG4gICAgeyB4OiAwLCB5OiAwIH0sXG4gICAgeyB4OiB3ICsgaCAvIDIsIHk6IDAgfSxcbiAgICB7IHg6IHcsIHk6IC1oIC8gMiB9LFxuICAgIHsgeDogdyArIGggLyAyLCB5OiAtaCB9LFxuICAgIHsgeDogMCwgeTogLWggfVxuICBdO1xuICBjb25zdCBlbCA9IGluc2VydFBvbHlnb25TaGFwZShzaGFwZVN2ZywgdywgaCwgcG9pbnRzKTtcbiAgZWwuYXR0cihcInN0eWxlXCIsIG5vZGUuc3R5bGUpO1xuICB1cGRhdGVOb2RlQm91bmRzKG5vZGUsIGVsKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LnBvbHlnb24obm9kZSwgcG9pbnRzLCBwb2ludDIpO1xuICB9O1xuICByZXR1cm4gc2hhcGVTdmc7XG59O1xuY29uc3QgY3lsaW5kZXIgPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHsgc2hhcGVTdmcsIGJib3ggfSA9IGF3YWl0IGxhYmVsSGVscGVyKFxuICAgIHBhcmVudCxcbiAgICBub2RlLFxuICAgIGdldENsYXNzZXNGcm9tTm9kZShub2RlLCB2b2lkIDApLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgdyA9IGJib3gud2lkdGggKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IHJ4ID0gdyAvIDI7XG4gIGNvbnN0IHJ5ID0gcnggLyAoMi41ICsgdyAvIDUwKTtcbiAgY29uc3QgaCA9IGJib3guaGVpZ2h0ICsgcnkgKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IHNoYXBlID0gXCJNIDAsXCIgKyByeSArIFwiIGEgXCIgKyByeCArIFwiLFwiICsgcnkgKyBcIiAwLDAsMCBcIiArIHcgKyBcIiAwIGEgXCIgKyByeCArIFwiLFwiICsgcnkgKyBcIiAwLDAsMCBcIiArIC13ICsgXCIgMCBsIDAsXCIgKyBoICsgXCIgYSBcIiArIHJ4ICsgXCIsXCIgKyByeSArIFwiIDAsMCwwIFwiICsgdyArIFwiIDAgbCAwLFwiICsgLWg7XG4gIGNvbnN0IGVsID0gc2hhcGVTdmcuYXR0cihcImxhYmVsLW9mZnNldC15XCIsIHJ5KS5pbnNlcnQoXCJwYXRoXCIsIFwiOmZpcnN0LWNoaWxkXCIpLmF0dHIoXCJzdHlsZVwiLCBub2RlLnN0eWxlKS5hdHRyKFwiZFwiLCBzaGFwZSkuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC13IC8gMiArIFwiLFwiICsgLShoIC8gMiArIHJ5KSArIFwiKVwiKTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCBlbCk7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgY29uc3QgcG9zID0gaW50ZXJzZWN0LnJlY3Qobm9kZSwgcG9pbnQyKTtcbiAgICBjb25zdCB4ID0gcG9zLnggLSBub2RlLng7XG4gICAgaWYgKHJ4ICE9IDAgJiYgKE1hdGguYWJzKHgpIDwgbm9kZS53aWR0aCAvIDIgfHwgTWF0aC5hYnMoeCkgPT0gbm9kZS53aWR0aCAvIDIgJiYgTWF0aC5hYnMocG9zLnkgLSBub2RlLnkpID4gbm9kZS5oZWlnaHQgLyAyIC0gcnkpKSB7XG4gICAgICBsZXQgeSA9IHJ5ICogcnkgKiAoMSAtIHggKiB4IC8gKHJ4ICogcngpKTtcbiAgICAgIGlmICh5ICE9IDApIHtcbiAgICAgICAgeSA9IE1hdGguc3FydCh5KTtcbiAgICAgIH1cbiAgICAgIHkgPSByeSAtIHk7XG4gICAgICBpZiAocG9pbnQyLnkgLSBub2RlLnkgPiAwKSB7XG4gICAgICAgIHkgPSAteTtcbiAgICAgIH1cbiAgICAgIHBvcy55ICs9IHk7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCByZWN0ID0gYXN5bmMgKHBhcmVudCwgbm9kZSkgPT4ge1xuICBjb25zdCB7IHNoYXBlU3ZnLCBiYm94LCBoYWxmUGFkZGluZyB9ID0gYXdhaXQgbGFiZWxIZWxwZXIoXG4gICAgcGFyZW50LFxuICAgIG5vZGUsXG4gICAgXCJub2RlIFwiICsgbm9kZS5jbGFzc2VzICsgXCIgXCIgKyBub2RlLmNsYXNzLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBjb25zdCB0b3RhbFdpZHRoID0gbm9kZS5wb3NpdGlvbmVkID8gbm9kZS53aWR0aCA6IGJib3gud2lkdGggKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IHRvdGFsSGVpZ2h0ID0gbm9kZS5wb3NpdGlvbmVkID8gbm9kZS5oZWlnaHQgOiBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgeCA9IG5vZGUucG9zaXRpb25lZCA/IC10b3RhbFdpZHRoIC8gMiA6IC1iYm94LndpZHRoIC8gMiAtIGhhbGZQYWRkaW5nO1xuICBjb25zdCB5ID0gbm9kZS5wb3NpdGlvbmVkID8gLXRvdGFsSGVpZ2h0IC8gMiA6IC1iYm94LmhlaWdodCAvIDIgLSBoYWxmUGFkZGluZztcbiAgcmVjdDIuYXR0cihcImNsYXNzXCIsIFwiYmFzaWMgbGFiZWwtY29udGFpbmVyXCIpLmF0dHIoXCJzdHlsZVwiLCBub2RlLnN0eWxlKS5hdHRyKFwicnhcIiwgbm9kZS5yeCkuYXR0cihcInJ5XCIsIG5vZGUucnkpLmF0dHIoXCJ4XCIsIHgpLmF0dHIoXCJ5XCIsIHkpLmF0dHIoXCJ3aWR0aFwiLCB0b3RhbFdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIHRvdGFsSGVpZ2h0KTtcbiAgaWYgKG5vZGUucHJvcHMpIHtcbiAgICBjb25zdCBwcm9wS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMobm9kZS5wcm9wcykpO1xuICAgIGlmIChub2RlLnByb3BzLmJvcmRlcnMpIHtcbiAgICAgIGFwcGx5Tm9kZVByb3BlcnR5Qm9yZGVycyhyZWN0Miwgbm9kZS5wcm9wcy5ib3JkZXJzLCB0b3RhbFdpZHRoLCB0b3RhbEhlaWdodCk7XG4gICAgICBwcm9wS2V5cy5kZWxldGUoXCJib3JkZXJzXCIpO1xuICAgIH1cbiAgICBwcm9wS2V5cy5mb3JFYWNoKChwcm9wS2V5KSA9PiB7XG4gICAgICBsb2cud2FybihgVW5rbm93biBub2RlIHByb3BlcnR5ICR7cHJvcEtleX1gKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVOb2RlQm91bmRzKG5vZGUsIHJlY3QyKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LnJlY3Qobm9kZSwgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IGNvbXBvc2l0ZSA9IGFzeW5jIChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3QgeyBzaGFwZVN2ZywgYmJveCwgaGFsZlBhZGRpbmcgfSA9IGF3YWl0IGxhYmVsSGVscGVyKFxuICAgIHBhcmVudCxcbiAgICBub2RlLFxuICAgIFwibm9kZSBcIiArIG5vZGUuY2xhc3NlcyxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IHJlY3QyID0gc2hhcGVTdmcuaW5zZXJ0KFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgY29uc3QgdG90YWxXaWR0aCA9IG5vZGUucG9zaXRpb25lZCA/IG5vZGUud2lkdGggOiBiYm94LndpZHRoICsgbm9kZS5wYWRkaW5nO1xuICBjb25zdCB0b3RhbEhlaWdodCA9IG5vZGUucG9zaXRpb25lZCA/IG5vZGUuaGVpZ2h0IDogYmJveC5oZWlnaHQgKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IHggPSBub2RlLnBvc2l0aW9uZWQgPyAtdG90YWxXaWR0aCAvIDIgOiAtYmJveC53aWR0aCAvIDIgLSBoYWxmUGFkZGluZztcbiAgY29uc3QgeSA9IG5vZGUucG9zaXRpb25lZCA/IC10b3RhbEhlaWdodCAvIDIgOiAtYmJveC5oZWlnaHQgLyAyIC0gaGFsZlBhZGRpbmc7XG4gIHJlY3QyLmF0dHIoXCJjbGFzc1wiLCBcImJhc2ljIGNsdXN0ZXIgY29tcG9zaXRlIGxhYmVsLWNvbnRhaW5lclwiKS5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSkuYXR0cihcInJ4XCIsIG5vZGUucngpLmF0dHIoXCJyeVwiLCBub2RlLnJ5KS5hdHRyKFwieFwiLCB4KS5hdHRyKFwieVwiLCB5KS5hdHRyKFwid2lkdGhcIiwgdG90YWxXaWR0aCkuYXR0cihcImhlaWdodFwiLCB0b3RhbEhlaWdodCk7XG4gIGlmIChub2RlLnByb3BzKSB7XG4gICAgY29uc3QgcHJvcEtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKG5vZGUucHJvcHMpKTtcbiAgICBpZiAobm9kZS5wcm9wcy5ib3JkZXJzKSB7XG4gICAgICBhcHBseU5vZGVQcm9wZXJ0eUJvcmRlcnMocmVjdDIsIG5vZGUucHJvcHMuYm9yZGVycywgdG90YWxXaWR0aCwgdG90YWxIZWlnaHQpO1xuICAgICAgcHJvcEtleXMuZGVsZXRlKFwiYm9yZGVyc1wiKTtcbiAgICB9XG4gICAgcHJvcEtleXMuZm9yRWFjaCgocHJvcEtleSkgPT4ge1xuICAgICAgbG9nLndhcm4oYFVua25vd24gbm9kZSBwcm9wZXJ0eSAke3Byb3BLZXl9YCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCByZWN0Mik7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdC5yZWN0KG5vZGUsIHBvaW50Mik7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCBsYWJlbFJlY3QgPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHsgc2hhcGVTdmcgfSA9IGF3YWl0IGxhYmVsSGVscGVyKHBhcmVudCwgbm9kZSwgXCJsYWJlbFwiLCB0cnVlKTtcbiAgbG9nLnRyYWNlKFwiQ2xhc3NlcyA9IFwiLCBub2RlLmNsYXNzKTtcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBjb25zdCB0b3RhbFdpZHRoID0gMDtcbiAgY29uc3QgdG90YWxIZWlnaHQgPSAwO1xuICByZWN0Mi5hdHRyKFwid2lkdGhcIiwgdG90YWxXaWR0aCkuYXR0cihcImhlaWdodFwiLCB0b3RhbEhlaWdodCk7XG4gIHNoYXBlU3ZnLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsIGVkZ2VMYWJlbFwiKTtcbiAgaWYgKG5vZGUucHJvcHMpIHtcbiAgICBjb25zdCBwcm9wS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMobm9kZS5wcm9wcykpO1xuICAgIGlmIChub2RlLnByb3BzLmJvcmRlcnMpIHtcbiAgICAgIGFwcGx5Tm9kZVByb3BlcnR5Qm9yZGVycyhyZWN0Miwgbm9kZS5wcm9wcy5ib3JkZXJzLCB0b3RhbFdpZHRoLCB0b3RhbEhlaWdodCk7XG4gICAgICBwcm9wS2V5cy5kZWxldGUoXCJib3JkZXJzXCIpO1xuICAgIH1cbiAgICBwcm9wS2V5cy5mb3JFYWNoKChwcm9wS2V5KSA9PiB7XG4gICAgICBsb2cud2FybihgVW5rbm93biBub2RlIHByb3BlcnR5ICR7cHJvcEtleX1gKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVOb2RlQm91bmRzKG5vZGUsIHJlY3QyKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LnJlY3Qobm9kZSwgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmZ1bmN0aW9uIGFwcGx5Tm9kZVByb3BlcnR5Qm9yZGVycyhyZWN0MiwgYm9yZGVycywgdG90YWxXaWR0aCwgdG90YWxIZWlnaHQpIHtcbiAgY29uc3Qgc3Ryb2tlRGFzaEFycmF5ID0gW107XG4gIGNvbnN0IGFkZEJvcmRlciA9IChsZW5ndGgpID0+IHtcbiAgICBzdHJva2VEYXNoQXJyYXkucHVzaChsZW5ndGgsIDApO1xuICB9O1xuICBjb25zdCBza2lwQm9yZGVyID0gKGxlbmd0aCkgPT4ge1xuICAgIHN0cm9rZURhc2hBcnJheS5wdXNoKDAsIGxlbmd0aCk7XG4gIH07XG4gIGlmIChib3JkZXJzLmluY2x1ZGVzKFwidFwiKSkge1xuICAgIGxvZy5kZWJ1ZyhcImFkZCB0b3AgYm9yZGVyXCIpO1xuICAgIGFkZEJvcmRlcih0b3RhbFdpZHRoKTtcbiAgfSBlbHNlIHtcbiAgICBza2lwQm9yZGVyKHRvdGFsV2lkdGgpO1xuICB9XG4gIGlmIChib3JkZXJzLmluY2x1ZGVzKFwiclwiKSkge1xuICAgIGxvZy5kZWJ1ZyhcImFkZCByaWdodCBib3JkZXJcIik7XG4gICAgYWRkQm9yZGVyKHRvdGFsSGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICBza2lwQm9yZGVyKHRvdGFsSGVpZ2h0KTtcbiAgfVxuICBpZiAoYm9yZGVycy5pbmNsdWRlcyhcImJcIikpIHtcbiAgICBsb2cuZGVidWcoXCJhZGQgYm90dG9tIGJvcmRlclwiKTtcbiAgICBhZGRCb3JkZXIodG90YWxXaWR0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2tpcEJvcmRlcih0b3RhbFdpZHRoKTtcbiAgfVxuICBpZiAoYm9yZGVycy5pbmNsdWRlcyhcImxcIikpIHtcbiAgICBsb2cuZGVidWcoXCJhZGQgbGVmdCBib3JkZXJcIik7XG4gICAgYWRkQm9yZGVyKHRvdGFsSGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICBza2lwQm9yZGVyKHRvdGFsSGVpZ2h0KTtcbiAgfVxuICByZWN0Mi5hdHRyKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBzdHJva2VEYXNoQXJyYXkuam9pbihcIiBcIikpO1xufVxuY29uc3QgcmVjdFdpdGhUaXRsZSA9IChwYXJlbnQsIG5vZGUpID0+IHtcbiAgbGV0IGNsYXNzZXM7XG4gIGlmICghbm9kZS5jbGFzc2VzKSB7XG4gICAgY2xhc3NlcyA9IFwibm9kZSBkZWZhdWx0XCI7XG4gIH0gZWxzZSB7XG4gICAgY2xhc3NlcyA9IFwibm9kZSBcIiArIG5vZGUuY2xhc3NlcztcbiAgfVxuICBjb25zdCBzaGFwZVN2ZyA9IHBhcmVudC5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc2VzKS5hdHRyKFwiaWRcIiwgbm9kZS5kb21JZCB8fCBub2RlLmlkKTtcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBjb25zdCBpbm5lckxpbmUgPSBzaGFwZVN2Zy5pbnNlcnQoXCJsaW5lXCIpO1xuICBjb25zdCBsYWJlbCA9IHNoYXBlU3ZnLmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIik7XG4gIGNvbnN0IHRleHQyID0gbm9kZS5sYWJlbFRleHQuZmxhdCA/IG5vZGUubGFiZWxUZXh0LmZsYXQoKSA6IG5vZGUubGFiZWxUZXh0O1xuICBsZXQgdGl0bGUgPSBcIlwiO1xuICBpZiAodHlwZW9mIHRleHQyID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGl0bGUgPSB0ZXh0MlswXTtcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9IHRleHQyO1xuICB9XG4gIGxvZy5pbmZvKFwiTGFiZWwgdGV4dCBhYmM3OVwiLCB0aXRsZSwgdGV4dDIsIHR5cGVvZiB0ZXh0MiA9PT0gXCJvYmplY3RcIik7XG4gIGNvbnN0IHRleHQgPSBsYWJlbC5ub2RlKCkuYXBwZW5kQ2hpbGQoY3JlYXRlTGFiZWwkMSh0aXRsZSwgbm9kZS5sYWJlbFN0eWxlLCB0cnVlLCB0cnVlKSk7XG4gIGxldCBiYm94ID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIGlmIChldmFsdWF0ZShnZXRDb25maWcoKS5mbG93Y2hhcnQuaHRtbExhYmVscykpIHtcbiAgICBjb25zdCBkaXYgPSB0ZXh0LmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGR2ID0gc2VsZWN0KHRleHQpO1xuICAgIGJib3ggPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZHYuYXR0cihcIndpZHRoXCIsIGJib3gud2lkdGgpO1xuICAgIGR2LmF0dHIoXCJoZWlnaHRcIiwgYmJveC5oZWlnaHQpO1xuICB9XG4gIGxvZy5pbmZvKFwiVGV4dCAyXCIsIHRleHQyKTtcbiAgY29uc3QgdGV4dFJvd3MgPSB0ZXh0Mi5zbGljZSgxLCB0ZXh0Mi5sZW5ndGgpO1xuICBsZXQgdGl0bGVCb3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgY29uc3QgZGVzY3IgPSBsYWJlbC5ub2RlKCkuYXBwZW5kQ2hpbGQoXG4gICAgY3JlYXRlTGFiZWwkMSh0ZXh0Um93cy5qb2luID8gdGV4dFJvd3Muam9pbihcIjxici8+XCIpIDogdGV4dFJvd3MsIG5vZGUubGFiZWxTdHlsZSwgdHJ1ZSwgdHJ1ZSlcbiAgKTtcbiAgaWYgKGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSkge1xuICAgIGNvbnN0IGRpdiA9IGRlc2NyLmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGR2ID0gc2VsZWN0KGRlc2NyKTtcbiAgICBiYm94ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGR2LmF0dHIoXCJ3aWR0aFwiLCBiYm94LndpZHRoKTtcbiAgICBkdi5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0KTtcbiAgfVxuICBjb25zdCBoYWxmUGFkZGluZyA9IG5vZGUucGFkZGluZyAvIDI7XG4gIHNlbGVjdChkZXNjcikuYXR0cihcbiAgICBcInRyYW5zZm9ybVwiLFxuICAgIFwidHJhbnNsYXRlKCBcIiArIC8vICh0aXRsZUJveC53aWR0aCAtIGJib3gud2lkdGgpIC8gMiArXG4gICAgKGJib3gud2lkdGggPiB0aXRsZUJveC53aWR0aCA/IDAgOiAodGl0bGVCb3gud2lkdGggLSBiYm94LndpZHRoKSAvIDIpICsgXCIsIFwiICsgKHRpdGxlQm94LmhlaWdodCArIGhhbGZQYWRkaW5nICsgNSkgKyBcIilcIlxuICApO1xuICBzZWxlY3QodGV4dCkuYXR0cihcbiAgICBcInRyYW5zZm9ybVwiLFxuICAgIFwidHJhbnNsYXRlKCBcIiArIC8vICh0aXRsZUJveC53aWR0aCAtIGJib3gud2lkdGgpIC8gMiArXG4gICAgKGJib3gud2lkdGggPCB0aXRsZUJveC53aWR0aCA/IDAgOiAtKHRpdGxlQm94LndpZHRoIC0gYmJveC53aWR0aCkgLyAyKSArIFwiLCAwKVwiXG4gICk7XG4gIGJib3ggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpO1xuICBsYWJlbC5hdHRyKFxuICAgIFwidHJhbnNmb3JtXCIsXG4gICAgXCJ0cmFuc2xhdGUoXCIgKyAtYmJveC53aWR0aCAvIDIgKyBcIiwgXCIgKyAoLWJib3guaGVpZ2h0IC8gMiAtIGhhbGZQYWRkaW5nICsgMykgKyBcIilcIlxuICApO1xuICByZWN0Mi5hdHRyKFwiY2xhc3NcIiwgXCJvdXRlciB0aXRsZS1zdGF0ZVwiKS5hdHRyKFwieFwiLCAtYmJveC53aWR0aCAvIDIgLSBoYWxmUGFkZGluZykuYXR0cihcInlcIiwgLWJib3guaGVpZ2h0IC8gMiAtIGhhbGZQYWRkaW5nKS5hdHRyKFwid2lkdGhcIiwgYmJveC53aWR0aCArIG5vZGUucGFkZGluZykuYXR0cihcImhlaWdodFwiLCBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZyk7XG4gIGlubmVyTGluZS5hdHRyKFwiY2xhc3NcIiwgXCJkaXZpZGVyXCIpLmF0dHIoXCJ4MVwiLCAtYmJveC53aWR0aCAvIDIgLSBoYWxmUGFkZGluZykuYXR0cihcIngyXCIsIGJib3gud2lkdGggLyAyICsgaGFsZlBhZGRpbmcpLmF0dHIoXCJ5MVwiLCAtYmJveC5oZWlnaHQgLyAyIC0gaGFsZlBhZGRpbmcgKyB0aXRsZUJveC5oZWlnaHQgKyBoYWxmUGFkZGluZykuYXR0cihcInkyXCIsIC1iYm94LmhlaWdodCAvIDIgLSBoYWxmUGFkZGluZyArIHRpdGxlQm94LmhlaWdodCArIGhhbGZQYWRkaW5nKTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCByZWN0Mik7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdC5yZWN0KG5vZGUsIHBvaW50Mik7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCBzdGFkaXVtID0gYXN5bmMgKHBhcmVudCwgbm9kZSkgPT4ge1xuICBjb25zdCB7IHNoYXBlU3ZnLCBiYm94IH0gPSBhd2FpdCBsYWJlbEhlbHBlcihcbiAgICBwYXJlbnQsXG4gICAgbm9kZSxcbiAgICBnZXRDbGFzc2VzRnJvbU5vZGUobm9kZSwgdm9pZCAwKSxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IGggPSBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgdyA9IGJib3gud2lkdGggKyBoIC8gNCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpLmF0dHIoXCJzdHlsZVwiLCBub2RlLnN0eWxlKS5hdHRyKFwicnhcIiwgaCAvIDIpLmF0dHIoXCJyeVwiLCBoIC8gMikuYXR0cihcInhcIiwgLXcgLyAyKS5hdHRyKFwieVwiLCAtaCAvIDIpLmF0dHIoXCJ3aWR0aFwiLCB3KS5hdHRyKFwiaGVpZ2h0XCIsIGgpO1xuICB1cGRhdGVOb2RlQm91bmRzKG5vZGUsIHJlY3QyKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LnJlY3Qobm9kZSwgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IGNpcmNsZSA9IGFzeW5jIChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3QgeyBzaGFwZVN2ZywgYmJveCwgaGFsZlBhZGRpbmcgfSA9IGF3YWl0IGxhYmVsSGVscGVyKFxuICAgIHBhcmVudCxcbiAgICBub2RlLFxuICAgIGdldENsYXNzZXNGcm9tTm9kZShub2RlLCB2b2lkIDApLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgY2lyY2xlMiA9IHNoYXBlU3ZnLmluc2VydChcImNpcmNsZVwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgY2lyY2xlMi5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSkuYXR0cihcInJ4XCIsIG5vZGUucngpLmF0dHIoXCJyeVwiLCBub2RlLnJ5KS5hdHRyKFwiclwiLCBiYm94LndpZHRoIC8gMiArIGhhbGZQYWRkaW5nKS5hdHRyKFwid2lkdGhcIiwgYmJveC53aWR0aCArIG5vZGUucGFkZGluZykuYXR0cihcImhlaWdodFwiLCBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZyk7XG4gIGxvZy5pbmZvKFwiQ2lyY2xlIG1haW5cIik7XG4gIHVwZGF0ZU5vZGVCb3VuZHMobm9kZSwgY2lyY2xlMik7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgbG9nLmluZm8oXCJDaXJjbGUgaW50ZXJzZWN0XCIsIG5vZGUsIGJib3gud2lkdGggLyAyICsgaGFsZlBhZGRpbmcsIHBvaW50Mik7XG4gICAgcmV0dXJuIGludGVyc2VjdC5jaXJjbGUobm9kZSwgYmJveC53aWR0aCAvIDIgKyBoYWxmUGFkZGluZywgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IGRvdWJsZWNpcmNsZSA9IGFzeW5jIChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3QgeyBzaGFwZVN2ZywgYmJveCwgaGFsZlBhZGRpbmcgfSA9IGF3YWl0IGxhYmVsSGVscGVyKFxuICAgIHBhcmVudCxcbiAgICBub2RlLFxuICAgIGdldENsYXNzZXNGcm9tTm9kZShub2RlLCB2b2lkIDApLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgZ2FwID0gNTtcbiAgY29uc3QgY2lyY2xlR3JvdXAgPSBzaGFwZVN2Zy5pbnNlcnQoXCJnXCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBjb25zdCBvdXRlckNpcmNsZSA9IGNpcmNsZUdyb3VwLmluc2VydChcImNpcmNsZVwiKTtcbiAgY29uc3QgaW5uZXJDaXJjbGUgPSBjaXJjbGVHcm91cC5pbnNlcnQoXCJjaXJjbGVcIik7XG4gIGNpcmNsZUdyb3VwLmF0dHIoXCJjbGFzc1wiLCBub2RlLmNsYXNzKTtcbiAgb3V0ZXJDaXJjbGUuYXR0cihcInN0eWxlXCIsIG5vZGUuc3R5bGUpLmF0dHIoXCJyeFwiLCBub2RlLnJ4KS5hdHRyKFwicnlcIiwgbm9kZS5yeSkuYXR0cihcInJcIiwgYmJveC53aWR0aCAvIDIgKyBoYWxmUGFkZGluZyArIGdhcCkuYXR0cihcIndpZHRoXCIsIGJib3gud2lkdGggKyBub2RlLnBhZGRpbmcgKyBnYXAgKiAyKS5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0ICsgbm9kZS5wYWRkaW5nICsgZ2FwICogMik7XG4gIGlubmVyQ2lyY2xlLmF0dHIoXCJzdHlsZVwiLCBub2RlLnN0eWxlKS5hdHRyKFwicnhcIiwgbm9kZS5yeCkuYXR0cihcInJ5XCIsIG5vZGUucnkpLmF0dHIoXCJyXCIsIGJib3gud2lkdGggLyAyICsgaGFsZlBhZGRpbmcpLmF0dHIoXCJ3aWR0aFwiLCBiYm94LndpZHRoICsgbm9kZS5wYWRkaW5nKS5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0ICsgbm9kZS5wYWRkaW5nKTtcbiAgbG9nLmluZm8oXCJEb3VibGVDaXJjbGUgbWFpblwiKTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCBvdXRlckNpcmNsZSk7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgbG9nLmluZm8oXCJEb3VibGVDaXJjbGUgaW50ZXJzZWN0XCIsIG5vZGUsIGJib3gud2lkdGggLyAyICsgaGFsZlBhZGRpbmcgKyBnYXAsIHBvaW50Mik7XG4gICAgcmV0dXJuIGludGVyc2VjdC5jaXJjbGUobm9kZSwgYmJveC53aWR0aCAvIDIgKyBoYWxmUGFkZGluZyArIGdhcCwgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IHN1YnJvdXRpbmUgPSBhc3luYyAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHsgc2hhcGVTdmcsIGJib3ggfSA9IGF3YWl0IGxhYmVsSGVscGVyKFxuICAgIHBhcmVudCxcbiAgICBub2RlLFxuICAgIGdldENsYXNzZXNGcm9tTm9kZShub2RlLCB2b2lkIDApLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgdyA9IGJib3gud2lkdGggKyBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IGggPSBiYm94LmhlaWdodCArIG5vZGUucGFkZGluZztcbiAgY29uc3QgcG9pbnRzID0gW1xuICAgIHsgeDogMCwgeTogMCB9LFxuICAgIHsgeDogdywgeTogMCB9LFxuICAgIHsgeDogdywgeTogLWggfSxcbiAgICB7IHg6IDAsIHk6IC1oIH0sXG4gICAgeyB4OiAwLCB5OiAwIH0sXG4gICAgeyB4OiAtOCwgeTogMCB9LFxuICAgIHsgeDogdyArIDgsIHk6IDAgfSxcbiAgICB7IHg6IHcgKyA4LCB5OiAtaCB9LFxuICAgIHsgeDogLTgsIHk6IC1oIH0sXG4gICAgeyB4OiAtOCwgeTogMCB9XG4gIF07XG4gIGNvbnN0IGVsID0gaW5zZXJ0UG9seWdvblNoYXBlKHNoYXBlU3ZnLCB3LCBoLCBwb2ludHMpO1xuICBlbC5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSk7XG4gIHVwZGF0ZU5vZGVCb3VuZHMobm9kZSwgZWwpO1xuICBub2RlLmludGVyc2VjdCA9IGZ1bmN0aW9uKHBvaW50Mikge1xuICAgIHJldHVybiBpbnRlcnNlY3QucG9seWdvbihub2RlLCBwb2ludHMsIHBvaW50Mik7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCBzdGFydCA9IChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3Qgc2hhcGVTdmcgPSBwYXJlbnQuaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlIGRlZmF1bHRcIikuYXR0cihcImlkXCIsIG5vZGUuZG9tSWQgfHwgbm9kZS5pZCk7XG4gIGNvbnN0IGNpcmNsZTIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJjaXJjbGVcIiwgXCI6Zmlyc3QtY2hpbGRcIik7XG4gIGNpcmNsZTIuYXR0cihcImNsYXNzXCIsIFwic3RhdGUtc3RhcnRcIikuYXR0cihcInJcIiwgNykuYXR0cihcIndpZHRoXCIsIDE0KS5hdHRyKFwiaGVpZ2h0XCIsIDE0KTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCBjaXJjbGUyKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LmNpcmNsZShub2RlLCA3LCBwb2ludDIpO1xuICB9O1xuICByZXR1cm4gc2hhcGVTdmc7XG59O1xuY29uc3QgZm9ya0pvaW4gPSAocGFyZW50LCBub2RlLCBkaXIpID0+IHtcbiAgY29uc3Qgc2hhcGVTdmcgPSBwYXJlbnQuaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlIGRlZmF1bHRcIikuYXR0cihcImlkXCIsIG5vZGUuZG9tSWQgfHwgbm9kZS5pZCk7XG4gIGxldCB3aWR0aCA9IDcwO1xuICBsZXQgaGVpZ2h0ID0gMTA7XG4gIGlmIChkaXIgPT09IFwiTFJcIikge1xuICAgIHdpZHRoID0gMTA7XG4gICAgaGVpZ2h0ID0gNzA7XG4gIH1cbiAgY29uc3Qgc2hhcGUgPSBzaGFwZVN2Zy5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJ4XCIsIC0xICogd2lkdGggLyAyKS5hdHRyKFwieVwiLCAtMSAqIGhlaWdodCAvIDIpLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCkuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpLmF0dHIoXCJjbGFzc1wiLCBcImZvcmstam9pblwiKTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCBzaGFwZSk7XG4gIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyBub2RlLnBhZGRpbmcgLyAyO1xuICBub2RlLndpZHRoID0gbm9kZS53aWR0aCArIG5vZGUucGFkZGluZyAvIDI7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdC5yZWN0KG5vZGUsIHBvaW50Mik7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCBlbmQgPSAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHNoYXBlU3ZnID0gcGFyZW50Lmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwibm9kZSBkZWZhdWx0XCIpLmF0dHIoXCJpZFwiLCBub2RlLmRvbUlkIHx8IG5vZGUuaWQpO1xuICBjb25zdCBpbm5lckNpcmNsZSA9IHNoYXBlU3ZnLmluc2VydChcImNpcmNsZVwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgY29uc3QgY2lyY2xlMiA9IHNoYXBlU3ZnLmluc2VydChcImNpcmNsZVwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgY2lyY2xlMi5hdHRyKFwiY2xhc3NcIiwgXCJzdGF0ZS1zdGFydFwiKS5hdHRyKFwiclwiLCA3KS5hdHRyKFwid2lkdGhcIiwgMTQpLmF0dHIoXCJoZWlnaHRcIiwgMTQpO1xuICBpbm5lckNpcmNsZS5hdHRyKFwiY2xhc3NcIiwgXCJzdGF0ZS1lbmRcIikuYXR0cihcInJcIiwgNSkuYXR0cihcIndpZHRoXCIsIDEwKS5hdHRyKFwiaGVpZ2h0XCIsIDEwKTtcbiAgdXBkYXRlTm9kZUJvdW5kcyhub2RlLCBjaXJjbGUyKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LmNpcmNsZShub2RlLCA3LCBwb2ludDIpO1xuICB9O1xuICByZXR1cm4gc2hhcGVTdmc7XG59O1xuY29uc3QgY2xhc3NfYm94ID0gKHBhcmVudCwgbm9kZSkgPT4ge1xuICBjb25zdCBoYWxmUGFkZGluZyA9IG5vZGUucGFkZGluZyAvIDI7XG4gIGNvbnN0IHJvd1BhZGRpbmcgPSA0O1xuICBjb25zdCBsaW5lSGVpZ2h0ID0gODtcbiAgbGV0IGNsYXNzZXM7XG4gIGlmICghbm9kZS5jbGFzc2VzKSB7XG4gICAgY2xhc3NlcyA9IFwibm9kZSBkZWZhdWx0XCI7XG4gIH0gZWxzZSB7XG4gICAgY2xhc3NlcyA9IFwibm9kZSBcIiArIG5vZGUuY2xhc3NlcztcbiAgfVxuICBjb25zdCBzaGFwZVN2ZyA9IHBhcmVudC5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc2VzKS5hdHRyKFwiaWRcIiwgbm9kZS5kb21JZCB8fCBub2RlLmlkKTtcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBjb25zdCB0b3BMaW5lID0gc2hhcGVTdmcuaW5zZXJ0KFwibGluZVwiKTtcbiAgY29uc3QgYm90dG9tTGluZSA9IHNoYXBlU3ZnLmluc2VydChcImxpbmVcIik7XG4gIGxldCBtYXhXaWR0aCA9IDA7XG4gIGxldCBtYXhIZWlnaHQgPSByb3dQYWRkaW5nO1xuICBjb25zdCBsYWJlbENvbnRhaW5lciA9IHNoYXBlU3ZnLmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIik7XG4gIGxldCB2ZXJ0aWNhbFBvcyA9IDA7XG4gIGNvbnN0IGhhc0ludGVyZmFjZSA9IG5vZGUuY2xhc3NEYXRhLmFubm90YXRpb25zICYmIG5vZGUuY2xhc3NEYXRhLmFubm90YXRpb25zWzBdO1xuICBjb25zdCBpbnRlcmZhY2VMYWJlbFRleHQgPSBub2RlLmNsYXNzRGF0YS5hbm5vdGF0aW9uc1swXSA/IFwiwqtcIiArIG5vZGUuY2xhc3NEYXRhLmFubm90YXRpb25zWzBdICsgXCLCu1wiIDogXCJcIjtcbiAgY29uc3QgaW50ZXJmYWNlTGFiZWwgPSBsYWJlbENvbnRhaW5lci5ub2RlKCkuYXBwZW5kQ2hpbGQoY3JlYXRlTGFiZWwkMShpbnRlcmZhY2VMYWJlbFRleHQsIG5vZGUubGFiZWxTdHlsZSwgdHJ1ZSwgdHJ1ZSkpO1xuICBsZXQgaW50ZXJmYWNlQkJveCA9IGludGVyZmFjZUxhYmVsLmdldEJCb3goKTtcbiAgaWYgKGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSkge1xuICAgIGNvbnN0IGRpdiA9IGludGVyZmFjZUxhYmVsLmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGR2ID0gc2VsZWN0KGludGVyZmFjZUxhYmVsKTtcbiAgICBpbnRlcmZhY2VCQm94ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGR2LmF0dHIoXCJ3aWR0aFwiLCBpbnRlcmZhY2VCQm94LndpZHRoKTtcbiAgICBkdi5hdHRyKFwiaGVpZ2h0XCIsIGludGVyZmFjZUJCb3guaGVpZ2h0KTtcbiAgfVxuICBpZiAobm9kZS5jbGFzc0RhdGEuYW5ub3RhdGlvbnNbMF0pIHtcbiAgICBtYXhIZWlnaHQgKz0gaW50ZXJmYWNlQkJveC5oZWlnaHQgKyByb3dQYWRkaW5nO1xuICAgIG1heFdpZHRoICs9IGludGVyZmFjZUJCb3gud2lkdGg7XG4gIH1cbiAgbGV0IGNsYXNzVGl0bGVTdHJpbmcgPSBub2RlLmNsYXNzRGF0YS5sYWJlbDtcbiAgaWYgKG5vZGUuY2xhc3NEYXRhLnR5cGUgIT09IHZvaWQgMCAmJiBub2RlLmNsYXNzRGF0YS50eXBlICE9PSBcIlwiKSB7XG4gICAgaWYgKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSB7XG4gICAgICBjbGFzc1RpdGxlU3RyaW5nICs9IFwiJmx0O1wiICsgbm9kZS5jbGFzc0RhdGEudHlwZSArIFwiJmd0O1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc1RpdGxlU3RyaW5nICs9IFwiPFwiICsgbm9kZS5jbGFzc0RhdGEudHlwZSArIFwiPlwiO1xuICAgIH1cbiAgfVxuICBjb25zdCBjbGFzc1RpdGxlTGFiZWwgPSBsYWJlbENvbnRhaW5lci5ub2RlKCkuYXBwZW5kQ2hpbGQoY3JlYXRlTGFiZWwkMShjbGFzc1RpdGxlU3RyaW5nLCBub2RlLmxhYmVsU3R5bGUsIHRydWUsIHRydWUpKTtcbiAgc2VsZWN0KGNsYXNzVGl0bGVMYWJlbCkuYXR0cihcImNsYXNzXCIsIFwiY2xhc3NUaXRsZVwiKTtcbiAgbGV0IGNsYXNzVGl0bGVCQm94ID0gY2xhc3NUaXRsZUxhYmVsLmdldEJCb3goKTtcbiAgaWYgKGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSkge1xuICAgIGNvbnN0IGRpdiA9IGNsYXNzVGl0bGVMYWJlbC5jaGlsZHJlblswXTtcbiAgICBjb25zdCBkdiA9IHNlbGVjdChjbGFzc1RpdGxlTGFiZWwpO1xuICAgIGNsYXNzVGl0bGVCQm94ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGR2LmF0dHIoXCJ3aWR0aFwiLCBjbGFzc1RpdGxlQkJveC53aWR0aCk7XG4gICAgZHYuYXR0cihcImhlaWdodFwiLCBjbGFzc1RpdGxlQkJveC5oZWlnaHQpO1xuICB9XG4gIG1heEhlaWdodCArPSBjbGFzc1RpdGxlQkJveC5oZWlnaHQgKyByb3dQYWRkaW5nO1xuICBpZiAoY2xhc3NUaXRsZUJCb3gud2lkdGggPiBtYXhXaWR0aCkge1xuICAgIG1heFdpZHRoID0gY2xhc3NUaXRsZUJCb3gud2lkdGg7XG4gIH1cbiAgY29uc3QgY2xhc3NBdHRyaWJ1dGVzID0gW107XG4gIG5vZGUuY2xhc3NEYXRhLm1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkSW5mbyA9IG1lbWJlci5nZXREaXNwbGF5RGV0YWlscygpO1xuICAgIGxldCBwYXJzZWRUZXh0ID0gcGFyc2VkSW5mby5kaXNwbGF5VGV4dDtcbiAgICBpZiAoZ2V0Q29uZmlnKCkuZmxvd2NoYXJ0Lmh0bWxMYWJlbHMpIHtcbiAgICAgIHBhcnNlZFRleHQgPSBwYXJzZWRUZXh0LnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xuICAgIH1cbiAgICBjb25zdCBsYmwgPSBsYWJlbENvbnRhaW5lci5ub2RlKCkuYXBwZW5kQ2hpbGQoXG4gICAgICBjcmVhdGVMYWJlbCQxKFxuICAgICAgICBwYXJzZWRUZXh0LFxuICAgICAgICBwYXJzZWRJbmZvLmNzc1N0eWxlID8gcGFyc2VkSW5mby5jc3NTdHlsZSA6IG5vZGUubGFiZWxTdHlsZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgICk7XG4gICAgbGV0IGJib3ggPSBsYmwuZ2V0QkJveCgpO1xuICAgIGlmIChldmFsdWF0ZShnZXRDb25maWcoKS5mbG93Y2hhcnQuaHRtbExhYmVscykpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGxibC5jaGlsZHJlblswXTtcbiAgICAgIGNvbnN0IGR2ID0gc2VsZWN0KGxibCk7XG4gICAgICBiYm94ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZHYuYXR0cihcIndpZHRoXCIsIGJib3gud2lkdGgpO1xuICAgICAgZHYuYXR0cihcImhlaWdodFwiLCBiYm94LmhlaWdodCk7XG4gICAgfVxuICAgIGlmIChiYm94LndpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgIG1heFdpZHRoID0gYmJveC53aWR0aDtcbiAgICB9XG4gICAgbWF4SGVpZ2h0ICs9IGJib3guaGVpZ2h0ICsgcm93UGFkZGluZztcbiAgICBjbGFzc0F0dHJpYnV0ZXMucHVzaChsYmwpO1xuICB9KTtcbiAgbWF4SGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gIGNvbnN0IGNsYXNzTWV0aG9kcyA9IFtdO1xuICBub2RlLmNsYXNzRGF0YS5tZXRob2RzLmZvckVhY2goKG1lbWJlcikgPT4ge1xuICAgIGNvbnN0IHBhcnNlZEluZm8gPSBtZW1iZXIuZ2V0RGlzcGxheURldGFpbHMoKTtcbiAgICBsZXQgZGlzcGxheVRleHQgPSBwYXJzZWRJbmZvLmRpc3BsYXlUZXh0O1xuICAgIGlmIChnZXRDb25maWcoKS5mbG93Y2hhcnQuaHRtbExhYmVscykge1xuICAgICAgZGlzcGxheVRleHQgPSBkaXNwbGF5VGV4dC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICB9XG4gICAgY29uc3QgbGJsID0gbGFiZWxDb250YWluZXIubm9kZSgpLmFwcGVuZENoaWxkKFxuICAgICAgY3JlYXRlTGFiZWwkMShcbiAgICAgICAgZGlzcGxheVRleHQsXG4gICAgICAgIHBhcnNlZEluZm8uY3NzU3R5bGUgPyBwYXJzZWRJbmZvLmNzc1N0eWxlIDogbm9kZS5sYWJlbFN0eWxlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgKTtcbiAgICBsZXQgYmJveCA9IGxibC5nZXRCQm94KCk7XG4gICAgaWYgKGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSkge1xuICAgICAgY29uc3QgZGl2ID0gbGJsLmNoaWxkcmVuWzBdO1xuICAgICAgY29uc3QgZHYgPSBzZWxlY3QobGJsKTtcbiAgICAgIGJib3ggPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBkdi5hdHRyKFwid2lkdGhcIiwgYmJveC53aWR0aCk7XG4gICAgICBkdi5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGJib3gud2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgbWF4V2lkdGggPSBiYm94LndpZHRoO1xuICAgIH1cbiAgICBtYXhIZWlnaHQgKz0gYmJveC5oZWlnaHQgKyByb3dQYWRkaW5nO1xuICAgIGNsYXNzTWV0aG9kcy5wdXNoKGxibCk7XG4gIH0pO1xuICBtYXhIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgaWYgKGhhc0ludGVyZmFjZSkge1xuICAgIGxldCBkaWZmWDIgPSAobWF4V2lkdGggLSBpbnRlcmZhY2VCQm94LndpZHRoKSAvIDI7XG4gICAgc2VsZWN0KGludGVyZmFjZUxhYmVsKS5hdHRyKFxuICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgIFwidHJhbnNsYXRlKCBcIiArICgtMSAqIG1heFdpZHRoIC8gMiArIGRpZmZYMikgKyBcIiwgXCIgKyAtMSAqIG1heEhlaWdodCAvIDIgKyBcIilcIlxuICAgICk7XG4gICAgdmVydGljYWxQb3MgPSBpbnRlcmZhY2VCQm94LmhlaWdodCArIHJvd1BhZGRpbmc7XG4gIH1cbiAgbGV0IGRpZmZYID0gKG1heFdpZHRoIC0gY2xhc3NUaXRsZUJCb3gud2lkdGgpIC8gMjtcbiAgc2VsZWN0KGNsYXNzVGl0bGVMYWJlbCkuYXR0cihcbiAgICBcInRyYW5zZm9ybVwiLFxuICAgIFwidHJhbnNsYXRlKCBcIiArICgtMSAqIG1heFdpZHRoIC8gMiArIGRpZmZYKSArIFwiLCBcIiArICgtMSAqIG1heEhlaWdodCAvIDIgKyB2ZXJ0aWNhbFBvcykgKyBcIilcIlxuICApO1xuICB2ZXJ0aWNhbFBvcyArPSBjbGFzc1RpdGxlQkJveC5oZWlnaHQgKyByb3dQYWRkaW5nO1xuICB0b3BMaW5lLmF0dHIoXCJjbGFzc1wiLCBcImRpdmlkZXJcIikuYXR0cihcIngxXCIsIC1tYXhXaWR0aCAvIDIgLSBoYWxmUGFkZGluZykuYXR0cihcIngyXCIsIG1heFdpZHRoIC8gMiArIGhhbGZQYWRkaW5nKS5hdHRyKFwieTFcIiwgLW1heEhlaWdodCAvIDIgLSBoYWxmUGFkZGluZyArIGxpbmVIZWlnaHQgKyB2ZXJ0aWNhbFBvcykuYXR0cihcInkyXCIsIC1tYXhIZWlnaHQgLyAyIC0gaGFsZlBhZGRpbmcgKyBsaW5lSGVpZ2h0ICsgdmVydGljYWxQb3MpO1xuICB2ZXJ0aWNhbFBvcyArPSBsaW5lSGVpZ2h0O1xuICBjbGFzc0F0dHJpYnV0ZXMuZm9yRWFjaCgobGJsKSA9PiB7XG4gICAgc2VsZWN0KGxibCkuYXR0cihcbiAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICBcInRyYW5zbGF0ZSggXCIgKyAtbWF4V2lkdGggLyAyICsgXCIsIFwiICsgKC0xICogbWF4SGVpZ2h0IC8gMiArIHZlcnRpY2FsUG9zICsgbGluZUhlaWdodCAvIDIpICsgXCIpXCJcbiAgICApO1xuICAgIGNvbnN0IG1lbWJlckJCb3ggPSBsYmwgPT0gbnVsbCA/IHZvaWQgMCA6IGxibC5nZXRCQm94KCk7XG4gICAgdmVydGljYWxQb3MgKz0gKChtZW1iZXJCQm94ID09IG51bGwgPyB2b2lkIDAgOiBtZW1iZXJCQm94LmhlaWdodCkgPz8gMCkgKyByb3dQYWRkaW5nO1xuICB9KTtcbiAgdmVydGljYWxQb3MgKz0gbGluZUhlaWdodDtcbiAgYm90dG9tTGluZS5hdHRyKFwiY2xhc3NcIiwgXCJkaXZpZGVyXCIpLmF0dHIoXCJ4MVwiLCAtbWF4V2lkdGggLyAyIC0gaGFsZlBhZGRpbmcpLmF0dHIoXCJ4MlwiLCBtYXhXaWR0aCAvIDIgKyBoYWxmUGFkZGluZykuYXR0cihcInkxXCIsIC1tYXhIZWlnaHQgLyAyIC0gaGFsZlBhZGRpbmcgKyBsaW5lSGVpZ2h0ICsgdmVydGljYWxQb3MpLmF0dHIoXCJ5MlwiLCAtbWF4SGVpZ2h0IC8gMiAtIGhhbGZQYWRkaW5nICsgbGluZUhlaWdodCArIHZlcnRpY2FsUG9zKTtcbiAgdmVydGljYWxQb3MgKz0gbGluZUhlaWdodDtcbiAgY2xhc3NNZXRob2RzLmZvckVhY2goKGxibCkgPT4ge1xuICAgIHNlbGVjdChsYmwpLmF0dHIoXG4gICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgXCJ0cmFuc2xhdGUoIFwiICsgLW1heFdpZHRoIC8gMiArIFwiLCBcIiArICgtMSAqIG1heEhlaWdodCAvIDIgKyB2ZXJ0aWNhbFBvcykgKyBcIilcIlxuICAgICk7XG4gICAgY29uc3QgbWVtYmVyQkJveCA9IGxibCA9PSBudWxsID8gdm9pZCAwIDogbGJsLmdldEJCb3goKTtcbiAgICB2ZXJ0aWNhbFBvcyArPSAoKG1lbWJlckJCb3ggPT0gbnVsbCA/IHZvaWQgMCA6IG1lbWJlckJCb3guaGVpZ2h0KSA/PyAwKSArIHJvd1BhZGRpbmc7XG4gIH0pO1xuICByZWN0Mi5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSkuYXR0cihcImNsYXNzXCIsIFwib3V0ZXIgdGl0bGUtc3RhdGVcIikuYXR0cihcInhcIiwgLW1heFdpZHRoIC8gMiAtIGhhbGZQYWRkaW5nKS5hdHRyKFwieVwiLCAtKG1heEhlaWdodCAvIDIpIC0gaGFsZlBhZGRpbmcpLmF0dHIoXCJ3aWR0aFwiLCBtYXhXaWR0aCArIG5vZGUucGFkZGluZykuYXR0cihcImhlaWdodFwiLCBtYXhIZWlnaHQgKyBub2RlLnBhZGRpbmcpO1xuICB1cGRhdGVOb2RlQm91bmRzKG5vZGUsIHJlY3QyKTtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludDIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0LnJlY3Qobm9kZSwgcG9pbnQyKTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IHNoYXBlcyA9IHtcbiAgcmhvbWJ1czogcXVlc3Rpb24sXG4gIGNvbXBvc2l0ZSxcbiAgcXVlc3Rpb24sXG4gIHJlY3QsXG4gIGxhYmVsUmVjdCxcbiAgcmVjdFdpdGhUaXRsZSxcbiAgY2hvaWNlLFxuICBjaXJjbGUsXG4gIGRvdWJsZWNpcmNsZSxcbiAgc3RhZGl1bSxcbiAgaGV4YWdvbixcbiAgYmxvY2tfYXJyb3csXG4gIHJlY3RfbGVmdF9pbnZfYXJyb3csXG4gIGxlYW5fcmlnaHQsXG4gIGxlYW5fbGVmdCxcbiAgdHJhcGV6b2lkLFxuICBpbnZfdHJhcGV6b2lkLFxuICByZWN0X3JpZ2h0X2ludl9hcnJvdyxcbiAgY3lsaW5kZXIsXG4gIHN0YXJ0LFxuICBlbmQsXG4gIG5vdGU6IG5vdGUkMSxcbiAgc3Vicm91dGluZSxcbiAgZm9yazogZm9ya0pvaW4sXG4gIGpvaW46IGZvcmtKb2luLFxuICBjbGFzc19ib3hcbn07XG5sZXQgbm9kZUVsZW1zID0ge307XG5jb25zdCBpbnNlcnROb2RlID0gYXN5bmMgKGVsZW0sIG5vZGUsIGRpcikgPT4ge1xuICBsZXQgbmV3RWw7XG4gIGxldCBlbDtcbiAgaWYgKG5vZGUubGluaykge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgaWYgKGdldENvbmZpZygpLnNlY3VyaXR5TGV2ZWwgPT09IFwic2FuZGJveFwiKSB7XG4gICAgICB0YXJnZXQgPSBcIl90b3BcIjtcbiAgICB9IGVsc2UgaWYgKG5vZGUubGlua1RhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gbm9kZS5saW5rVGFyZ2V0IHx8IFwiX2JsYW5rXCI7XG4gICAgfVxuICAgIG5ld0VsID0gZWxlbS5pbnNlcnQoXCJzdmc6YVwiKS5hdHRyKFwieGxpbms6aHJlZlwiLCBub2RlLmxpbmspLmF0dHIoXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICBlbCA9IGF3YWl0IHNoYXBlc1tub2RlLnNoYXBlXShuZXdFbCwgbm9kZSwgZGlyKTtcbiAgfSBlbHNlIHtcbiAgICBlbCA9IGF3YWl0IHNoYXBlc1tub2RlLnNoYXBlXShlbGVtLCBub2RlLCBkaXIpO1xuICAgIG5ld0VsID0gZWw7XG4gIH1cbiAgaWYgKG5vZGUudG9vbHRpcCkge1xuICAgIGVsLmF0dHIoXCJ0aXRsZVwiLCBub2RlLnRvb2x0aXApO1xuICB9XG4gIGlmIChub2RlLmNsYXNzKSB7XG4gICAgZWwuYXR0cihcImNsYXNzXCIsIFwibm9kZSBkZWZhdWx0IFwiICsgbm9kZS5jbGFzcyk7XG4gIH1cbiAgbmV3RWwuYXR0cihcImRhdGEtbm9kZVwiLCBcInRydWVcIik7XG4gIG5ld0VsLmF0dHIoXCJkYXRhLWlkXCIsIG5vZGUuaWQpO1xuICBub2RlRWxlbXNbbm9kZS5pZF0gPSBuZXdFbDtcbiAgaWYgKG5vZGUuaGF2ZUNhbGxiYWNrKSB7XG4gICAgbm9kZUVsZW1zW25vZGUuaWRdLmF0dHIoXCJjbGFzc1wiLCBub2RlRWxlbXNbbm9kZS5pZF0uYXR0cihcImNsYXNzXCIpICsgXCIgY2xpY2thYmxlXCIpO1xuICB9XG4gIHJldHVybiBuZXdFbDtcbn07XG5jb25zdCBzZXROb2RlRWxlbSA9IChlbGVtLCBub2RlKSA9PiB7XG4gIG5vZGVFbGVtc1tub2RlLmlkXSA9IGVsZW07XG59O1xuY29uc3QgY2xlYXIkMSA9ICgpID0+IHtcbiAgbm9kZUVsZW1zID0ge307XG59O1xuY29uc3QgcG9zaXRpb25Ob2RlID0gKG5vZGUpID0+IHtcbiAgY29uc3QgZWwgPSBub2RlRWxlbXNbbm9kZS5pZF07XG4gIGxvZy50cmFjZShcbiAgICBcIlRyYW5zZm9ybWluZyBub2RlXCIsXG4gICAgbm9kZS5kaWZmLFxuICAgIG5vZGUsXG4gICAgXCJ0cmFuc2xhdGUoXCIgKyAobm9kZS54IC0gbm9kZS53aWR0aCAvIDIgLSA1KSArIFwiLCBcIiArIG5vZGUud2lkdGggLyAyICsgXCIpXCJcbiAgKTtcbiAgY29uc3QgcGFkZGluZyA9IDg7XG4gIGNvbnN0IGRpZmYgPSBub2RlLmRpZmYgfHwgMDtcbiAgaWYgKG5vZGUuY2x1c3Rlck5vZGUpIHtcbiAgICBlbC5hdHRyKFxuICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgIFwidHJhbnNsYXRlKFwiICsgKG5vZGUueCArIGRpZmYgLSBub2RlLndpZHRoIC8gMikgKyBcIiwgXCIgKyAobm9kZS55IC0gbm9kZS5oZWlnaHQgLyAyIC0gcGFkZGluZykgKyBcIilcIlxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgZWwuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG5vZGUueCArIFwiLCBcIiArIG5vZGUueSArIFwiKVwiKTtcbiAgfVxuICByZXR1cm4gZGlmZjtcbn07XG5jb25zdCBnZXRTdWJHcmFwaFRpdGxlTWFyZ2lucyA9ICh7XG4gIGZsb3djaGFydFxufSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBzdWJHcmFwaFRpdGxlVG9wTWFyZ2luID0gKChfYSA9IGZsb3djaGFydCA9PSBudWxsID8gdm9pZCAwIDogZmxvd2NoYXJ0LnN1YkdyYXBoVGl0bGVNYXJnaW4pID09IG51bGwgPyB2b2lkIDAgOiBfYS50b3ApID8/IDA7XG4gIGNvbnN0IHN1YkdyYXBoVGl0bGVCb3R0b21NYXJnaW4gPSAoKF9iID0gZmxvd2NoYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBmbG93Y2hhcnQuc3ViR3JhcGhUaXRsZU1hcmdpbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJvdHRvbSkgPz8gMDtcbiAgY29uc3Qgc3ViR3JhcGhUaXRsZVRvdGFsTWFyZ2luID0gc3ViR3JhcGhUaXRsZVRvcE1hcmdpbiArIHN1YkdyYXBoVGl0bGVCb3R0b21NYXJnaW47XG4gIHJldHVybiB7XG4gICAgc3ViR3JhcGhUaXRsZVRvcE1hcmdpbixcbiAgICBzdWJHcmFwaFRpdGxlQm90dG9tTWFyZ2luLFxuICAgIHN1YkdyYXBoVGl0bGVUb3RhbE1hcmdpblxuICB9O1xufTtcbmNvbnN0IG1hcmtlck9mZnNldHMgPSB7XG4gIGFnZ3JlZ2F0aW9uOiAxOCxcbiAgZXh0ZW5zaW9uOiAxOCxcbiAgY29tcG9zaXRpb246IDE4LFxuICBkZXBlbmRlbmN5OiA2LFxuICBsb2xsaXBvcDogMTMuNSxcbiAgYXJyb3dfcG9pbnQ6IDUuM1xufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhQW5kQW5nbGUocG9pbnQxLCBwb2ludDIpIHtcbiAgaWYgKHBvaW50MSA9PT0gdm9pZCAwIHx8IHBvaW50MiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgYW5nbGU6IDAsIGRlbHRhWDogMCwgZGVsdGFZOiAwIH07XG4gIH1cbiAgcG9pbnQxID0gcG9pbnRUcmFuc2Zvcm1lcihwb2ludDEpO1xuICBwb2ludDIgPSBwb2ludFRyYW5zZm9ybWVyKHBvaW50Mik7XG4gIGNvbnN0IFt4MSwgeTFdID0gW3BvaW50MS54LCBwb2ludDEueV07XG4gIGNvbnN0IFt4MiwgeTJdID0gW3BvaW50Mi54LCBwb2ludDIueV07XG4gIGNvbnN0IGRlbHRhWCA9IHgyIC0geDE7XG4gIGNvbnN0IGRlbHRhWSA9IHkyIC0geTE7XG4gIHJldHVybiB7IGFuZ2xlOiBNYXRoLmF0YW4oZGVsdGFZIC8gZGVsdGFYKSwgZGVsdGFYLCBkZWx0YVkgfTtcbn1cbmNvbnN0IHBvaW50VHJhbnNmb3JtZXIgPSAoZGF0YSkgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiB7IHg6IGRhdGFbMF0sIHk6IGRhdGFbMV0gfTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG5jb25zdCBnZXRMaW5lRnVuY3Rpb25zV2l0aE9mZnNldCA9IChlZGdlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgeDogZnVuY3Rpb24oZCwgaSwgZGF0YSkge1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBpZiAoaSA9PT0gMCAmJiBPYmplY3QuaGFzT3duKG1hcmtlck9mZnNldHMsIGVkZ2UuYXJyb3dUeXBlU3RhcnQpKSB7XG4gICAgICAgIGNvbnN0IHsgYW5nbGUsIGRlbHRhWCB9ID0gY2FsY3VsYXRlRGVsdGFBbmRBbmdsZShkYXRhWzBdLCBkYXRhWzFdKTtcbiAgICAgICAgb2Zmc2V0ID0gbWFya2VyT2Zmc2V0c1tlZGdlLmFycm93VHlwZVN0YXJ0XSAqIE1hdGguY29zKGFuZ2xlKSAqIChkZWx0YVggPj0gMCA/IDEgOiAtMSk7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IGRhdGEubGVuZ3RoIC0gMSAmJiBPYmplY3QuaGFzT3duKG1hcmtlck9mZnNldHMsIGVkZ2UuYXJyb3dUeXBlRW5kKSkge1xuICAgICAgICBjb25zdCB7IGFuZ2xlLCBkZWx0YVggfSA9IGNhbGN1bGF0ZURlbHRhQW5kQW5nbGUoXG4gICAgICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAyXVxuICAgICAgICApO1xuICAgICAgICBvZmZzZXQgPSBtYXJrZXJPZmZzZXRzW2VkZ2UuYXJyb3dUeXBlRW5kXSAqIE1hdGguY29zKGFuZ2xlKSAqIChkZWx0YVggPj0gMCA/IDEgOiAtMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnRUcmFuc2Zvcm1lcihkKS54ICsgb2Zmc2V0O1xuICAgIH0sXG4gICAgeTogZnVuY3Rpb24oZCwgaSwgZGF0YSkge1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBpZiAoaSA9PT0gMCAmJiBPYmplY3QuaGFzT3duKG1hcmtlck9mZnNldHMsIGVkZ2UuYXJyb3dUeXBlU3RhcnQpKSB7XG4gICAgICAgIGNvbnN0IHsgYW5nbGUsIGRlbHRhWSB9ID0gY2FsY3VsYXRlRGVsdGFBbmRBbmdsZShkYXRhWzBdLCBkYXRhWzFdKTtcbiAgICAgICAgb2Zmc2V0ID0gbWFya2VyT2Zmc2V0c1tlZGdlLmFycm93VHlwZVN0YXJ0XSAqIE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSkgKiAoZGVsdGFZID49IDAgPyAxIDogLTEpO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBkYXRhLmxlbmd0aCAtIDEgJiYgT2JqZWN0Lmhhc093bihtYXJrZXJPZmZzZXRzLCBlZGdlLmFycm93VHlwZUVuZCkpIHtcbiAgICAgICAgY29uc3QgeyBhbmdsZSwgZGVsdGFZIH0gPSBjYWxjdWxhdGVEZWx0YUFuZEFuZ2xlKFxuICAgICAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXSxcbiAgICAgICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMl1cbiAgICAgICAgKTtcbiAgICAgICAgb2Zmc2V0ID0gbWFya2VyT2Zmc2V0c1tlZGdlLmFycm93VHlwZUVuZF0gKiBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpICogKGRlbHRhWSA+PSAwID8gMSA6IC0xKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludFRyYW5zZm9ybWVyKGQpLnkgKyBvZmZzZXQ7XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IGFkZEVkZ2VNYXJrZXJzID0gKHN2Z1BhdGgsIGVkZ2UsIHVybCwgaWQsIGRpYWdyYW1UeXBlKSA9PiB7XG4gIGlmIChlZGdlLmFycm93VHlwZVN0YXJ0KSB7XG4gICAgYWRkRWRnZU1hcmtlcihzdmdQYXRoLCBcInN0YXJ0XCIsIGVkZ2UuYXJyb3dUeXBlU3RhcnQsIHVybCwgaWQsIGRpYWdyYW1UeXBlKTtcbiAgfVxuICBpZiAoZWRnZS5hcnJvd1R5cGVFbmQpIHtcbiAgICBhZGRFZGdlTWFya2VyKHN2Z1BhdGgsIFwiZW5kXCIsIGVkZ2UuYXJyb3dUeXBlRW5kLCB1cmwsIGlkLCBkaWFncmFtVHlwZSk7XG4gIH1cbn07XG5jb25zdCBhcnJvd1R5cGVzTWFwID0ge1xuICBhcnJvd19jcm9zczogXCJjcm9zc1wiLFxuICBhcnJvd19wb2ludDogXCJwb2ludFwiLFxuICBhcnJvd19iYXJiOiBcImJhcmJcIixcbiAgYXJyb3dfY2lyY2xlOiBcImNpcmNsZVwiLFxuICBhZ2dyZWdhdGlvbjogXCJhZ2dyZWdhdGlvblwiLFxuICBleHRlbnNpb246IFwiZXh0ZW5zaW9uXCIsXG4gIGNvbXBvc2l0aW9uOiBcImNvbXBvc2l0aW9uXCIsXG4gIGRlcGVuZGVuY3k6IFwiZGVwZW5kZW5jeVwiLFxuICBsb2xsaXBvcDogXCJsb2xsaXBvcFwiXG59O1xuY29uc3QgYWRkRWRnZU1hcmtlciA9IChzdmdQYXRoLCBwb3NpdGlvbiwgYXJyb3dUeXBlLCB1cmwsIGlkLCBkaWFncmFtVHlwZSkgPT4ge1xuICBjb25zdCBlbmRNYXJrZXJUeXBlID0gYXJyb3dUeXBlc01hcFthcnJvd1R5cGVdO1xuICBpZiAoIWVuZE1hcmtlclR5cGUpIHtcbiAgICBsb2cud2FybihgVW5rbm93biBhcnJvdyB0eXBlOiAke2Fycm93VHlwZX1gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3VmZml4ID0gcG9zaXRpb24gPT09IFwic3RhcnRcIiA/IFwiU3RhcnRcIiA6IFwiRW5kXCI7XG4gIHN2Z1BhdGguYXR0cihgbWFya2VyLSR7cG9zaXRpb259YCwgYHVybCgke3VybH0jJHtpZH1fJHtkaWFncmFtVHlwZX0tJHtlbmRNYXJrZXJUeXBlfSR7c3VmZml4fSlgKTtcbn07XG5sZXQgZWRnZUxhYmVscyA9IHt9O1xubGV0IHRlcm1pbmFsTGFiZWxzID0ge307XG5jb25zdCBjbGVhciA9ICgpID0+IHtcbiAgZWRnZUxhYmVscyA9IHt9O1xuICB0ZXJtaW5hbExhYmVscyA9IHt9O1xufTtcbmNvbnN0IGluc2VydEVkZ2VMYWJlbCA9IChlbGVtLCBlZGdlKSA9PiB7XG4gIGNvbnN0IHVzZUh0bWxMYWJlbHMgPSBldmFsdWF0ZShnZXRDb25maWcoKS5mbG93Y2hhcnQuaHRtbExhYmVscyk7XG4gIGNvbnN0IGxhYmVsRWxlbWVudCA9IGVkZ2UubGFiZWxUeXBlID09PSBcIm1hcmtkb3duXCIgPyBjcmVhdGVUZXh0KGVsZW0sIGVkZ2UubGFiZWwsIHtcbiAgICBzdHlsZTogZWRnZS5sYWJlbFN0eWxlLFxuICAgIHVzZUh0bWxMYWJlbHMsXG4gICAgYWRkU3ZnQmFja2dyb3VuZDogdHJ1ZVxuICB9KSA6IGNyZWF0ZUxhYmVsJDEoZWRnZS5sYWJlbCwgZWRnZS5sYWJlbFN0eWxlKTtcbiAgY29uc3QgZWRnZUxhYmVsID0gZWxlbS5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImVkZ2VMYWJlbFwiKTtcbiAgY29uc3QgbGFiZWwgPSBlZGdlTGFiZWwuaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKTtcbiAgbGFiZWwubm9kZSgpLmFwcGVuZENoaWxkKGxhYmVsRWxlbWVudCk7XG4gIGxldCBiYm94ID0gbGFiZWxFbGVtZW50LmdldEJCb3goKTtcbiAgaWYgKHVzZUh0bWxMYWJlbHMpIHtcbiAgICBjb25zdCBkaXYgPSBsYWJlbEVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgZHYgPSBzZWxlY3QobGFiZWxFbGVtZW50KTtcbiAgICBiYm94ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGR2LmF0dHIoXCJ3aWR0aFwiLCBiYm94LndpZHRoKTtcbiAgICBkdi5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0KTtcbiAgfVxuICBsYWJlbC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLWJib3gud2lkdGggLyAyICsgXCIsIFwiICsgLWJib3guaGVpZ2h0IC8gMiArIFwiKVwiKTtcbiAgZWRnZUxhYmVsc1tlZGdlLmlkXSA9IGVkZ2VMYWJlbDtcbiAgZWRnZS53aWR0aCA9IGJib3gud2lkdGg7XG4gIGVkZ2UuaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gIGxldCBmbztcbiAgaWYgKGVkZ2Uuc3RhcnRMYWJlbExlZnQpIHtcbiAgICBjb25zdCBzdGFydExhYmVsRWxlbWVudCA9IGNyZWF0ZUxhYmVsJDEoZWRnZS5zdGFydExhYmVsTGVmdCwgZWRnZS5sYWJlbFN0eWxlKTtcbiAgICBjb25zdCBzdGFydEVkZ2VMYWJlbExlZnQgPSBlbGVtLmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiZWRnZVRlcm1pbmFsc1wiKTtcbiAgICBjb25zdCBpbm5lciA9IHN0YXJ0RWRnZUxhYmVsTGVmdC5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImlubmVyXCIpO1xuICAgIGZvID0gaW5uZXIubm9kZSgpLmFwcGVuZENoaWxkKHN0YXJ0TGFiZWxFbGVtZW50KTtcbiAgICBjb25zdCBzbEJveCA9IHN0YXJ0TGFiZWxFbGVtZW50LmdldEJCb3goKTtcbiAgICBpbm5lci5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgLXNsQm94LndpZHRoIC8gMiArIFwiLCBcIiArIC1zbEJveC5oZWlnaHQgLyAyICsgXCIpXCIpO1xuICAgIGlmICghdGVybWluYWxMYWJlbHNbZWRnZS5pZF0pIHtcbiAgICAgIHRlcm1pbmFsTGFiZWxzW2VkZ2UuaWRdID0ge307XG4gICAgfVxuICAgIHRlcm1pbmFsTGFiZWxzW2VkZ2UuaWRdLnN0YXJ0TGVmdCA9IHN0YXJ0RWRnZUxhYmVsTGVmdDtcbiAgICBzZXRUZXJtaW5hbFdpZHRoKGZvLCBlZGdlLnN0YXJ0TGFiZWxMZWZ0KTtcbiAgfVxuICBpZiAoZWRnZS5zdGFydExhYmVsUmlnaHQpIHtcbiAgICBjb25zdCBzdGFydExhYmVsRWxlbWVudCA9IGNyZWF0ZUxhYmVsJDEoZWRnZS5zdGFydExhYmVsUmlnaHQsIGVkZ2UubGFiZWxTdHlsZSk7XG4gICAgY29uc3Qgc3RhcnRFZGdlTGFiZWxSaWdodCA9IGVsZW0uaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJlZGdlVGVybWluYWxzXCIpO1xuICAgIGNvbnN0IGlubmVyID0gc3RhcnRFZGdlTGFiZWxSaWdodC5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImlubmVyXCIpO1xuICAgIGZvID0gc3RhcnRFZGdlTGFiZWxSaWdodC5ub2RlKCkuYXBwZW5kQ2hpbGQoc3RhcnRMYWJlbEVsZW1lbnQpO1xuICAgIGlubmVyLm5vZGUoKS5hcHBlbmRDaGlsZChzdGFydExhYmVsRWxlbWVudCk7XG4gICAgY29uc3Qgc2xCb3ggPSBzdGFydExhYmVsRWxlbWVudC5nZXRCQm94KCk7XG4gICAgaW5uZXIuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1zbEJveC53aWR0aCAvIDIgKyBcIiwgXCIgKyAtc2xCb3guaGVpZ2h0IC8gMiArIFwiKVwiKTtcbiAgICBpZiAoIXRlcm1pbmFsTGFiZWxzW2VkZ2UuaWRdKSB7XG4gICAgICB0ZXJtaW5hbExhYmVsc1tlZGdlLmlkXSA9IHt9O1xuICAgIH1cbiAgICB0ZXJtaW5hbExhYmVsc1tlZGdlLmlkXS5zdGFydFJpZ2h0ID0gc3RhcnRFZGdlTGFiZWxSaWdodDtcbiAgICBzZXRUZXJtaW5hbFdpZHRoKGZvLCBlZGdlLnN0YXJ0TGFiZWxSaWdodCk7XG4gIH1cbiAgaWYgKGVkZ2UuZW5kTGFiZWxMZWZ0KSB7XG4gICAgY29uc3QgZW5kTGFiZWxFbGVtZW50ID0gY3JlYXRlTGFiZWwkMShlZGdlLmVuZExhYmVsTGVmdCwgZWRnZS5sYWJlbFN0eWxlKTtcbiAgICBjb25zdCBlbmRFZGdlTGFiZWxMZWZ0ID0gZWxlbS5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImVkZ2VUZXJtaW5hbHNcIik7XG4gICAgY29uc3QgaW5uZXIgPSBlbmRFZGdlTGFiZWxMZWZ0Lmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiaW5uZXJcIik7XG4gICAgZm8gPSBpbm5lci5ub2RlKCkuYXBwZW5kQ2hpbGQoZW5kTGFiZWxFbGVtZW50KTtcbiAgICBjb25zdCBzbEJveCA9IGVuZExhYmVsRWxlbWVudC5nZXRCQm94KCk7XG4gICAgaW5uZXIuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1zbEJveC53aWR0aCAvIDIgKyBcIiwgXCIgKyAtc2xCb3guaGVpZ2h0IC8gMiArIFwiKVwiKTtcbiAgICBlbmRFZGdlTGFiZWxMZWZ0Lm5vZGUoKS5hcHBlbmRDaGlsZChlbmRMYWJlbEVsZW1lbnQpO1xuICAgIGlmICghdGVybWluYWxMYWJlbHNbZWRnZS5pZF0pIHtcbiAgICAgIHRlcm1pbmFsTGFiZWxzW2VkZ2UuaWRdID0ge307XG4gICAgfVxuICAgIHRlcm1pbmFsTGFiZWxzW2VkZ2UuaWRdLmVuZExlZnQgPSBlbmRFZGdlTGFiZWxMZWZ0O1xuICAgIHNldFRlcm1pbmFsV2lkdGgoZm8sIGVkZ2UuZW5kTGFiZWxMZWZ0KTtcbiAgfVxuICBpZiAoZWRnZS5lbmRMYWJlbFJpZ2h0KSB7XG4gICAgY29uc3QgZW5kTGFiZWxFbGVtZW50ID0gY3JlYXRlTGFiZWwkMShlZGdlLmVuZExhYmVsUmlnaHQsIGVkZ2UubGFiZWxTdHlsZSk7XG4gICAgY29uc3QgZW5kRWRnZUxhYmVsUmlnaHQgPSBlbGVtLmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiZWRnZVRlcm1pbmFsc1wiKTtcbiAgICBjb25zdCBpbm5lciA9IGVuZEVkZ2VMYWJlbFJpZ2h0Lmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiaW5uZXJcIik7XG4gICAgZm8gPSBpbm5lci5ub2RlKCkuYXBwZW5kQ2hpbGQoZW5kTGFiZWxFbGVtZW50KTtcbiAgICBjb25zdCBzbEJveCA9IGVuZExhYmVsRWxlbWVudC5nZXRCQm94KCk7XG4gICAgaW5uZXIuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIC1zbEJveC53aWR0aCAvIDIgKyBcIiwgXCIgKyAtc2xCb3guaGVpZ2h0IC8gMiArIFwiKVwiKTtcbiAgICBlbmRFZGdlTGFiZWxSaWdodC5ub2RlKCkuYXBwZW5kQ2hpbGQoZW5kTGFiZWxFbGVtZW50KTtcbiAgICBpZiAoIXRlcm1pbmFsTGFiZWxzW2VkZ2UuaWRdKSB7XG4gICAgICB0ZXJtaW5hbExhYmVsc1tlZGdlLmlkXSA9IHt9O1xuICAgIH1cbiAgICB0ZXJtaW5hbExhYmVsc1tlZGdlLmlkXS5lbmRSaWdodCA9IGVuZEVkZ2VMYWJlbFJpZ2h0O1xuICAgIHNldFRlcm1pbmFsV2lkdGgoZm8sIGVkZ2UuZW5kTGFiZWxSaWdodCk7XG4gIH1cbiAgcmV0dXJuIGxhYmVsRWxlbWVudDtcbn07XG5mdW5jdGlvbiBzZXRUZXJtaW5hbFdpZHRoKGZvLCB2YWx1ZSkge1xuICBpZiAoZ2V0Q29uZmlnKCkuZmxvd2NoYXJ0Lmh0bWxMYWJlbHMgJiYgZm8pIHtcbiAgICBmby5zdHlsZS53aWR0aCA9IHZhbHVlLmxlbmd0aCAqIDkgKyBcInB4XCI7XG4gICAgZm8uc3R5bGUuaGVpZ2h0ID0gXCIxMnB4XCI7XG4gIH1cbn1cbmNvbnN0IHBvc2l0aW9uRWRnZUxhYmVsID0gKGVkZ2UsIHBhdGhzKSA9PiB7XG4gIGxvZy5kZWJ1ZyhcIk1vdmluZyBsYWJlbCBhYmM4OCBcIiwgZWRnZS5pZCwgZWRnZS5sYWJlbCwgZWRnZUxhYmVsc1tlZGdlLmlkXSwgcGF0aHMpO1xuICBsZXQgcGF0aCA9IHBhdGhzLnVwZGF0ZWRQYXRoID8gcGF0aHMudXBkYXRlZFBhdGggOiBwYXRocy5vcmlnaW5hbFBhdGg7XG4gIGNvbnN0IHNpdGVDb25maWcgPSBnZXRDb25maWcoKTtcbiAgY29uc3QgeyBzdWJHcmFwaFRpdGxlVG90YWxNYXJnaW4gfSA9IGdldFN1YkdyYXBoVGl0bGVNYXJnaW5zKHNpdGVDb25maWcpO1xuICBpZiAoZWRnZS5sYWJlbCkge1xuICAgIGNvbnN0IGVsID0gZWRnZUxhYmVsc1tlZGdlLmlkXTtcbiAgICBsZXQgeCA9IGVkZ2UueDtcbiAgICBsZXQgeSA9IGVkZ2UueTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgY29uc3QgcG9zID0gdXRpbHMuY2FsY0xhYmVsUG9zaXRpb24ocGF0aCk7XG4gICAgICBsb2cuZGVidWcoXG4gICAgICAgIFwiTW92aW5nIGxhYmVsIFwiICsgZWRnZS5sYWJlbCArIFwiIGZyb20gKFwiLFxuICAgICAgICB4LFxuICAgICAgICBcIixcIixcbiAgICAgICAgeSxcbiAgICAgICAgXCIpIHRvIChcIixcbiAgICAgICAgcG9zLngsXG4gICAgICAgIFwiLFwiLFxuICAgICAgICBwb3MueSxcbiAgICAgICAgXCIpIGFiYzg4XCJcbiAgICAgICk7XG4gICAgICBpZiAocGF0aHMudXBkYXRlZFBhdGgpIHtcbiAgICAgICAgeCA9IHBvcy54O1xuICAgICAgICB5ID0gcG9zLnk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3h9LCAke3kgKyBzdWJHcmFwaFRpdGxlVG90YWxNYXJnaW4gLyAyfSlgKTtcbiAgfVxuICBpZiAoZWRnZS5zdGFydExhYmVsTGVmdCkge1xuICAgIGNvbnN0IGVsID0gdGVybWluYWxMYWJlbHNbZWRnZS5pZF0uc3RhcnRMZWZ0O1xuICAgIGxldCB4ID0gZWRnZS54O1xuICAgIGxldCB5ID0gZWRnZS55O1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBjb25zdCBwb3MgPSB1dGlscy5jYWxjVGVybWluYWxMYWJlbFBvc2l0aW9uKGVkZ2UuYXJyb3dUeXBlU3RhcnQgPyAxMCA6IDAsIFwic3RhcnRfbGVmdFwiLCBwYXRoKTtcbiAgICAgIHggPSBwb3MueDtcbiAgICAgIHkgPSBwb3MueTtcbiAgICB9XG4gICAgZWwuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYCk7XG4gIH1cbiAgaWYgKGVkZ2Uuc3RhcnRMYWJlbFJpZ2h0KSB7XG4gICAgY29uc3QgZWwgPSB0ZXJtaW5hbExhYmVsc1tlZGdlLmlkXS5zdGFydFJpZ2h0O1xuICAgIGxldCB4ID0gZWRnZS54O1xuICAgIGxldCB5ID0gZWRnZS55O1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBjb25zdCBwb3MgPSB1dGlscy5jYWxjVGVybWluYWxMYWJlbFBvc2l0aW9uKFxuICAgICAgICBlZGdlLmFycm93VHlwZVN0YXJ0ID8gMTAgOiAwLFxuICAgICAgICBcInN0YXJ0X3JpZ2h0XCIsXG4gICAgICAgIHBhdGhcbiAgICAgICk7XG4gICAgICB4ID0gcG9zLng7XG4gICAgICB5ID0gcG9zLnk7XG4gICAgfVxuICAgIGVsLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3h9LCAke3l9KWApO1xuICB9XG4gIGlmIChlZGdlLmVuZExhYmVsTGVmdCkge1xuICAgIGNvbnN0IGVsID0gdGVybWluYWxMYWJlbHNbZWRnZS5pZF0uZW5kTGVmdDtcbiAgICBsZXQgeCA9IGVkZ2UueDtcbiAgICBsZXQgeSA9IGVkZ2UueTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgY29uc3QgcG9zID0gdXRpbHMuY2FsY1Rlcm1pbmFsTGFiZWxQb3NpdGlvbihlZGdlLmFycm93VHlwZUVuZCA/IDEwIDogMCwgXCJlbmRfbGVmdFwiLCBwYXRoKTtcbiAgICAgIHggPSBwb3MueDtcbiAgICAgIHkgPSBwb3MueTtcbiAgICB9XG4gICAgZWwuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYCk7XG4gIH1cbiAgaWYgKGVkZ2UuZW5kTGFiZWxSaWdodCkge1xuICAgIGNvbnN0IGVsID0gdGVybWluYWxMYWJlbHNbZWRnZS5pZF0uZW5kUmlnaHQ7XG4gICAgbGV0IHggPSBlZGdlLng7XG4gICAgbGV0IHkgPSBlZGdlLnk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHV0aWxzLmNhbGNUZXJtaW5hbExhYmVsUG9zaXRpb24oZWRnZS5hcnJvd1R5cGVFbmQgPyAxMCA6IDAsIFwiZW5kX3JpZ2h0XCIsIHBhdGgpO1xuICAgICAgeCA9IHBvcy54O1xuICAgICAgeSA9IHBvcy55O1xuICAgIH1cbiAgICBlbC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgKTtcbiAgfVxufTtcbmNvbnN0IG91dHNpZGVOb2RlID0gKG5vZGUsIHBvaW50MikgPT4ge1xuICBjb25zdCB4ID0gbm9kZS54O1xuICBjb25zdCB5ID0gbm9kZS55O1xuICBjb25zdCBkeCA9IE1hdGguYWJzKHBvaW50Mi54IC0geCk7XG4gIGNvbnN0IGR5ID0gTWF0aC5hYnMocG9pbnQyLnkgLSB5KTtcbiAgY29uc3QgdyA9IG5vZGUud2lkdGggLyAyO1xuICBjb25zdCBoID0gbm9kZS5oZWlnaHQgLyAyO1xuICBpZiAoZHggPj0gdyB8fCBkeSA+PSBoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGludGVyc2VjdGlvbiA9IChub2RlLCBvdXRzaWRlUG9pbnQsIGluc2lkZVBvaW50KSA9PiB7XG4gIGxvZy5kZWJ1ZyhgaW50ZXJzZWN0aW9uIGNhbGMgYWJjODk6XG4gIG91dHNpZGVQb2ludDogJHtKU09OLnN0cmluZ2lmeShvdXRzaWRlUG9pbnQpfVxuICBpbnNpZGVQb2ludCA6ICR7SlNPTi5zdHJpbmdpZnkoaW5zaWRlUG9pbnQpfVxuICBub2RlICAgICAgICA6IHg6JHtub2RlLnh9IHk6JHtub2RlLnl9IHc6JHtub2RlLndpZHRofSBoOiR7bm9kZS5oZWlnaHR9YCk7XG4gIGNvbnN0IHggPSBub2RlLng7XG4gIGNvbnN0IHkgPSBub2RlLnk7XG4gIGNvbnN0IGR4ID0gTWF0aC5hYnMoeCAtIGluc2lkZVBvaW50LngpO1xuICBjb25zdCB3ID0gbm9kZS53aWR0aCAvIDI7XG4gIGxldCByID0gaW5zaWRlUG9pbnQueCA8IG91dHNpZGVQb2ludC54ID8gdyAtIGR4IDogdyArIGR4O1xuICBjb25zdCBoID0gbm9kZS5oZWlnaHQgLyAyO1xuICBjb25zdCBRID0gTWF0aC5hYnMob3V0c2lkZVBvaW50LnkgLSBpbnNpZGVQb2ludC55KTtcbiAgY29uc3QgUiA9IE1hdGguYWJzKG91dHNpZGVQb2ludC54IC0gaW5zaWRlUG9pbnQueCk7XG4gIGlmIChNYXRoLmFicyh5IC0gb3V0c2lkZVBvaW50LnkpICogdyA+IE1hdGguYWJzKHggLSBvdXRzaWRlUG9pbnQueCkgKiBoKSB7XG4gICAgbGV0IHEgPSBpbnNpZGVQb2ludC55IDwgb3V0c2lkZVBvaW50LnkgPyBvdXRzaWRlUG9pbnQueSAtIGggLSB5IDogeSAtIGggLSBvdXRzaWRlUG9pbnQueTtcbiAgICByID0gUiAqIHEgLyBRO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIHg6IGluc2lkZVBvaW50LnggPCBvdXRzaWRlUG9pbnQueCA/IGluc2lkZVBvaW50LnggKyByIDogaW5zaWRlUG9pbnQueCAtIFIgKyByLFxuICAgICAgeTogaW5zaWRlUG9pbnQueSA8IG91dHNpZGVQb2ludC55ID8gaW5zaWRlUG9pbnQueSArIFEgLSBxIDogaW5zaWRlUG9pbnQueSAtIFEgKyBxXG4gICAgfTtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgcmVzLnggPSBvdXRzaWRlUG9pbnQueDtcbiAgICAgIHJlcy55ID0gb3V0c2lkZVBvaW50Lnk7XG4gICAgfVxuICAgIGlmIChSID09PSAwKSB7XG4gICAgICByZXMueCA9IG91dHNpZGVQb2ludC54O1xuICAgIH1cbiAgICBpZiAoUSA9PT0gMCkge1xuICAgICAgcmVzLnkgPSBvdXRzaWRlUG9pbnQueTtcbiAgICB9XG4gICAgbG9nLmRlYnVnKGBhYmM4OSB0b3BwL2JvdHQgY2FsYywgUSAke1F9LCBxICR7cX0sIFIgJHtSfSwgciAke3J9YCwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2Uge1xuICAgIGlmIChpbnNpZGVQb2ludC54IDwgb3V0c2lkZVBvaW50LngpIHtcbiAgICAgIHIgPSBvdXRzaWRlUG9pbnQueCAtIHcgLSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICByID0geCAtIHcgLSBvdXRzaWRlUG9pbnQueDtcbiAgICB9XG4gICAgbGV0IHEgPSBRICogciAvIFI7XG4gICAgbGV0IF94ID0gaW5zaWRlUG9pbnQueCA8IG91dHNpZGVQb2ludC54ID8gaW5zaWRlUG9pbnQueCArIFIgLSByIDogaW5zaWRlUG9pbnQueCAtIFIgKyByO1xuICAgIGxldCBfeSA9IGluc2lkZVBvaW50LnkgPCBvdXRzaWRlUG9pbnQueSA/IGluc2lkZVBvaW50LnkgKyBxIDogaW5zaWRlUG9pbnQueSAtIHE7XG4gICAgbG9nLmRlYnVnKGBzaWRlcyBjYWxjIGFiYzg5LCBRICR7UX0sIHEgJHtxfSwgUiAke1J9LCByICR7cn1gLCB7IF94LCBfeSB9KTtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgX3ggPSBvdXRzaWRlUG9pbnQueDtcbiAgICAgIF95ID0gb3V0c2lkZVBvaW50Lnk7XG4gICAgfVxuICAgIGlmIChSID09PSAwKSB7XG4gICAgICBfeCA9IG91dHNpZGVQb2ludC54O1xuICAgIH1cbiAgICBpZiAoUSA9PT0gMCkge1xuICAgICAgX3kgPSBvdXRzaWRlUG9pbnQueTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogX3gsIHk6IF95IH07XG4gIH1cbn07XG5jb25zdCBjdXRQYXRoQXRJbnRlcnNlY3QgPSAoX3BvaW50cywgYm91bmRhcnlOb2RlKSA9PiB7XG4gIGxvZy5kZWJ1ZyhcImFiYzg4IGN1dFBhdGhBdEludGVyc2VjdFwiLCBfcG9pbnRzLCBib3VuZGFyeU5vZGUpO1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBsYXN0UG9pbnRPdXRzaWRlID0gX3BvaW50c1swXTtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIF9wb2ludHMuZm9yRWFjaCgocG9pbnQyKSA9PiB7XG4gICAgaWYgKCFvdXRzaWRlTm9kZShib3VuZGFyeU5vZGUsIHBvaW50MikgJiYgIWlzSW5zaWRlKSB7XG4gICAgICBjb25zdCBpbnRlciA9IGludGVyc2VjdGlvbihib3VuZGFyeU5vZGUsIGxhc3RQb2ludE91dHNpZGUsIHBvaW50Mik7XG4gICAgICBsZXQgcG9pbnRQcmVzZW50ID0gZmFsc2U7XG4gICAgICBwb2ludHMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBwb2ludFByZXNlbnQgPSBwb2ludFByZXNlbnQgfHwgcC54ID09PSBpbnRlci54ICYmIHAueSA9PT0gaW50ZXIueTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwb2ludHMuc29tZSgoZSkgPT4gZS54ID09PSBpbnRlci54ICYmIGUueSA9PT0gaW50ZXIueSkpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goaW50ZXIpO1xuICAgICAgfVxuICAgICAgaXNJbnNpZGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0UG9pbnRPdXRzaWRlID0gcG9pbnQyO1xuICAgICAgaWYgKCFpc0luc2lkZSkge1xuICAgICAgICBwb2ludHMucHVzaChwb2ludDIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59O1xuY29uc3QgaW5zZXJ0RWRnZSA9IGZ1bmN0aW9uKGVsZW0sIGUsIGVkZ2UsIGNsdXN0ZXJEYiwgZGlhZ3JhbVR5cGUsIGdyYXBoLCBpZCkge1xuICBsZXQgcG9pbnRzID0gZWRnZS5wb2ludHM7XG4gIGxvZy5kZWJ1ZyhcImFiYzg4IEluc2VydEVkZ2U6IGVkZ2U9XCIsIGVkZ2UsIFwiZT1cIiwgZSk7XG4gIGxldCBwb2ludHNIYXNDaGFuZ2VkID0gZmFsc2U7XG4gIGNvbnN0IHRhaWwgPSBncmFwaC5ub2RlKGUudik7XG4gIHZhciBoZWFkID0gZ3JhcGgubm9kZShlLncpO1xuICBpZiAoKGhlYWQgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWQuaW50ZXJzZWN0KSAmJiAodGFpbCA9PSBudWxsID8gdm9pZCAwIDogdGFpbC5pbnRlcnNlY3QpKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLnNsaWNlKDEsIGVkZ2UucG9pbnRzLmxlbmd0aCAtIDEpO1xuICAgIHBvaW50cy51bnNoaWZ0KHRhaWwuaW50ZXJzZWN0KHBvaW50c1swXSkpO1xuICAgIHBvaW50cy5wdXNoKGhlYWQuaW50ZXJzZWN0KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pKTtcbiAgfVxuICBpZiAoZWRnZS50b0NsdXN0ZXIpIHtcbiAgICBsb2cuZGVidWcoXCJ0byBjbHVzdGVyIGFiYzg4XCIsIGNsdXN0ZXJEYltlZGdlLnRvQ2x1c3Rlcl0pO1xuICAgIHBvaW50cyA9IGN1dFBhdGhBdEludGVyc2VjdChlZGdlLnBvaW50cywgY2x1c3RlckRiW2VkZ2UudG9DbHVzdGVyXS5ub2RlKTtcbiAgICBwb2ludHNIYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgfVxuICBpZiAoZWRnZS5mcm9tQ2x1c3Rlcikge1xuICAgIGxvZy5kZWJ1ZyhcImZyb20gY2x1c3RlciBhYmM4OFwiLCBjbHVzdGVyRGJbZWRnZS5mcm9tQ2x1c3Rlcl0pO1xuICAgIHBvaW50cyA9IGN1dFBhdGhBdEludGVyc2VjdChwb2ludHMucmV2ZXJzZSgpLCBjbHVzdGVyRGJbZWRnZS5mcm9tQ2x1c3Rlcl0ubm9kZSkucmV2ZXJzZSgpO1xuICAgIHBvaW50c0hhc0NoYW5nZWQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IGxpbmVEYXRhID0gcG9pbnRzLmZpbHRlcigocCkgPT4gIU51bWJlci5pc05hTihwLnkpKTtcbiAgbGV0IGN1cnZlID0gY3VydmVCYXNpcztcbiAgaWYgKGVkZ2UuY3VydmUgJiYgKGRpYWdyYW1UeXBlID09PSBcImdyYXBoXCIgfHwgZGlhZ3JhbVR5cGUgPT09IFwiZmxvd2NoYXJ0XCIpKSB7XG4gICAgY3VydmUgPSBlZGdlLmN1cnZlO1xuICB9XG4gIGNvbnN0IHsgeCwgeSB9ID0gZ2V0TGluZUZ1bmN0aW9uc1dpdGhPZmZzZXQoZWRnZSk7XG4gIGNvbnN0IGxpbmVGdW5jdGlvbiA9IGxpbmUoKS54KHgpLnkoeSkuY3VydmUoY3VydmUpO1xuICBsZXQgc3Ryb2tlQ2xhc3NlcztcbiAgc3dpdGNoIChlZGdlLnRoaWNrbmVzcykge1xuICAgIGNhc2UgXCJub3JtYWxcIjpcbiAgICAgIHN0cm9rZUNsYXNzZXMgPSBcImVkZ2UtdGhpY2tuZXNzLW5vcm1hbFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRoaWNrXCI6XG4gICAgICBzdHJva2VDbGFzc2VzID0gXCJlZGdlLXRoaWNrbmVzcy10aGlja1wiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImludmlzaWJsZVwiOlxuICAgICAgc3Ryb2tlQ2xhc3NlcyA9IFwiZWRnZS10aGlja25lc3MtdGhpY2tcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdHJva2VDbGFzc2VzID0gXCJcIjtcbiAgfVxuICBzd2l0Y2ggKGVkZ2UucGF0dGVybikge1xuICAgIGNhc2UgXCJzb2xpZFwiOlxuICAgICAgc3Ryb2tlQ2xhc3NlcyArPSBcIiBlZGdlLXBhdHRlcm4tc29saWRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkb3R0ZWRcIjpcbiAgICAgIHN0cm9rZUNsYXNzZXMgKz0gXCIgZWRnZS1wYXR0ZXJuLWRvdHRlZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRhc2hlZFwiOlxuICAgICAgc3Ryb2tlQ2xhc3NlcyArPSBcIiBlZGdlLXBhdHRlcm4tZGFzaGVkXCI7XG4gICAgICBicmVhaztcbiAgfVxuICBjb25zdCBzdmdQYXRoID0gZWxlbS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihsaW5lRGF0YSkpLmF0dHIoXCJpZFwiLCBlZGdlLmlkKS5hdHRyKFwiY2xhc3NcIiwgXCIgXCIgKyBzdHJva2VDbGFzc2VzICsgKGVkZ2UuY2xhc3NlcyA/IFwiIFwiICsgZWRnZS5jbGFzc2VzIDogXCJcIikpLmF0dHIoXCJzdHlsZVwiLCBlZGdlLnN0eWxlKTtcbiAgbGV0IHVybCA9IFwiXCI7XG4gIGlmIChnZXRDb25maWcoKS5mbG93Y2hhcnQuYXJyb3dNYXJrZXJBYnNvbHV0ZSB8fCBnZXRDb25maWcoKS5zdGF0ZS5hcnJvd01hcmtlckFic29sdXRlKSB7XG4gICAgdXJsID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICAgIHVybCA9IHVybC5yZXBsYWNlKC9cXCgvZywgXCJcXFxcKFwiKTtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwpL2csIFwiXFxcXClcIik7XG4gIH1cbiAgYWRkRWRnZU1hcmtlcnMoc3ZnUGF0aCwgZWRnZSwgdXJsLCBpZCwgZGlhZ3JhbVR5cGUpO1xuICBsZXQgcGF0aHMgPSB7fTtcbiAgaWYgKHBvaW50c0hhc0NoYW5nZWQpIHtcbiAgICBwYXRocy51cGRhdGVkUGF0aCA9IHBvaW50cztcbiAgfVxuICBwYXRocy5vcmlnaW5hbFBhdGggPSBlZGdlLnBvaW50cztcbiAgcmV0dXJuIHBhdGhzO1xufTtcbmV4cG9ydCB7XG4gIGluc2VydE1hcmtlcnMkMSBhcyBhLFxuICBjbGVhciQxIGFzIGIsXG4gIGNyZWF0ZUxhYmVsJDEgYXMgYyxcbiAgY2xlYXIgYXMgZCxcbiAgaW5zZXJ0Tm9kZSBhcyBlLFxuICBpbnNlcnRFZGdlTGFiZWwgYXMgZixcbiAgZ2V0U3ViR3JhcGhUaXRsZU1hcmdpbnMgYXMgZyxcbiAgaW5zZXJ0RWRnZSBhcyBoLFxuICBpbnRlcnNlY3RSZWN0JDEgYXMgaSxcbiAgcG9zaXRpb25FZGdlTGFiZWwgYXMgaixcbiAgZ2V0TGluZUZ1bmN0aW9uc1dpdGhPZmZzZXQgYXMgayxcbiAgbGFiZWxIZWxwZXIgYXMgbCxcbiAgYWRkRWRnZU1hcmtlcnMgYXMgbSxcbiAgcG9zaXRpb25Ob2RlIGFzIHAsXG4gIHNldE5vZGVFbGVtIGFzIHMsXG4gIHVwZGF0ZU5vZGVCb3VuZHMgYXMgdVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8055\n')}}]);